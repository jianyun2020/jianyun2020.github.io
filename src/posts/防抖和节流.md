---
categories:
    - 面试
tags:
    - 面试
    - 防抖和节流
---

# 防抖和节流

## 防抖

### 定义：指触发事件后在**规定时间内**回调函数**只能执行一次**，如果在规定时间内又触发了该事件，则会重新开始算规定时间。简而言之就是**延时执行**。

### 应用场景

两个条件：
1. 如果客户连续的操作会导致频繁的事件回调（可能引起页面卡顿）
2. 客户只关心“最后一次”操作（也可以理解为停止连续操作后）所返回的结果。

例如：
- 输入搜索联想，用户在不断输入值时，用防抖来节约请求资源。
- 按钮点击： 收藏、点赞、爱心等。

### 原理

通过定时器将回调函数进行延时，如果在规定时间内继续回调，发现存在之前的定时器，则将该定时器清除，并重新设置定时器。这里有个细节，就是后面所有的回调函数都要能访问到之前设置的定时器，这时就需要用到闭包（详情见后边）

防抖分为两种：
- 非立即执行：事件触发->延时->执行回调函数；如果在延时中，继续触发事件，则会重新进行延时，在延时结束后执行回调函数。常见的例子：input搜索框，客户输完过一会就会自动搜索。
- 立即执行：事件触发->执行回调函数->延时；如果在延时中，继续触发事件，则会重新进行延时。在延时结束后，并不会执行回调函数。常见的例子：对于按钮防点击，例如点赞，爱心，收藏等立即有反馈的按钮。

实现思路：
```js
// 非立即执行
// 回调函数
function showLog(content) {
    console.log('Log: ', content);
}

/* 包装函数
* 1.保存定时器标识
* 2.返回闭包函数：
*   1）对定时器的判断清除；
*   2）一般还需要保存函数的参数（一般就是事件返回的对象）和上下文（定时器存在this隐式丢失：详情见【我不知*      道的js 上】）
* 不建议通过定义一个全局变量来替闭包保存定时器标识。
*/
function debounce(fun, delay=500) {
    // let timer = null 保存定时器
    return function(args) {
        let that = this;
        let _args = args;
        // 这里对定时器的设置有两种方法，第一种就是将定时器保存在函数（函数也是对象）的属性上
        // 这种写法很简便，但不常用
        clearTimeout(fun.timer);
        fun.timer = setTimeout(function() {
            fun.call(that, _args);
        }, delay);
        // 另一种写法是比较常见的
        // if (timer) clearTimeout(timer); 相比上面的方法，这里多一个判断
        // timer = setTimeout(function() {
        //     fun.call(that, _args);
        // }, delay);
    }
}

// 接着用变量保存debounce返回的带有延时功能的函数
let debounceShowLog = debounce(showLog, 500);

// 最后添加事件监听，回调debounceShowLog并传入事件返回的对象
let input = document.getElementById('debounce');
input.addEventListener('keyup', function(e) {
    debounceShowLog(e.target.value);
});


// 立即执行
// 定时器中不再包含回调函数，而是在回调函数执行后，仅起到延时和重置定时器标识的作用
function debounce(fun, delay=500, immediate=true) {
    let timer = null; // 保存定时器
    return function(args) {
        let that = this;
        let _args = args;
        if (timer) clearTimeout(timer); // 不管是否立即执行都需要先清空定时器
        if (immediate) {
            if (!timer) fun.apply(that, _args); // 如果定时器不存在，则说明延时已过，可以立即执行函数
            timer = setTimeout(function() { // 不管上一个延时是否完成，都需要重置定时器
                timer = null; // 到时间后，定时器自动设为null，不仅方便判断定时器状态还能避免内存泄漏
            }, delay)
        } else {
            // 如果是非立即执行，则重新设定定时器，并将回调函数放入其中
            timer = setTimeout(function () {
                fun.call(that, _args);
            }, delay);
        }
    }
}
```