import projectConfig from '/pagic.config.js';
export default {
    config: { "root": "/", ...projectConfig, branch: 'main' },
    'pagePath': "posts/Vuex.md",
    'layoutPath': "posts/_layout.tsx",
    'outputPath': "posts/Vuex.html",
    'title': "Vuex",
    'content': React.createElement("article", { dangerouslySetInnerHTML: {
            __html: '<h1>Vuex</h1>\n<p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>\n<p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的<strong>状态 (state)</strong>。Vuex 和单纯的全局对象有以下两点不同：</p>\n<ol>\n<li>\n<p>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p>\n</li>\n<li>\n<p>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地<strong>提交 (commit) mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</p>\n</li>\n</ol>\n<h1>最简单的 Store</h1>\n<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">Vue</span></span> <span class="token keyword module">from</span> <span class="token string">\'vue\'</span>\n<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">Vuex</span></span> <span class="token keyword module">from</span> <span class="token string">\'vuex\'</span>\n\n<span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token method function property-access">use</span><span class="token punctuation">(</span><span class="token maybe-class-name">Vuex</span><span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    state<span class="token operator">:</span> <span class="token punctuation">{</span>\n        count<span class="token operator">:</span> <span class="token number">0</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    mutations<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            state<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token operator">++</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 现在，你可以通过 store.state 来获取状态对象，以及通过 store.commit 方法触发状态变更：</span>\nstore<span class="token punctuation">.</span><span class="token method function property-access">commit</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">)</span>\n\n<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>store<span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>\n\n<span class="token comment">// 为了在 Vue 组件中访问 this.$store property，你需要为 Vue 实例提供创建好的 store。Vuex 提供了一个从根组件向所有子组件，以 store 选项的方式“注入”该 store 的机制：</span>\n<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    el<span class="token operator">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n    store<span class="token operator">:</span> store\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 如果使用 ES6，你也可以以 ES6 对象的 property 简写 (用在对象某个 property 的 key 和被传入的变量同名时)：</span>\n\n<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  el<span class="token operator">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n  store\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 现在我们可以从组件的方法提交一个变更：</span>\nmethods<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$store</span><span class="token punctuation">.</span><span class="token method function property-access">commit</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">)</span>\n        <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$store</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p><em>再次强调，我们通过提交 mutation 的方式，而非直接改变 store.state.count，是因为我们想要更明确地追踪到状态的变化。</em></p>\n<p>由于 store 中的状态是响应式的，在组件中调用 store 中的状态简单到仅需要在<strong>计算属性</strong>中返回即可。触发变化也仅仅是在组件的 <strong>methods 中提交 mutation</strong>。</p>\n<h1>state</h1>\n<h2 id="%E5%8D%95%E4%B8%80%E7%8A%B6%E6%80%81%E6%A0%91">单一状态树<a class="anchor" href="#%E5%8D%95%E4%B8%80%E7%8A%B6%E6%80%81%E6%A0%91">§</a></h2>\n<p>Vuex 使用<strong>单一状态树</strong>——是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。</p>\n<h2 id="%E5%9C%A8-vue-%E7%BB%84%E4%BB%B6%E4%B8%AD%E8%8E%B7%E5%BE%97-vuex-%E7%8A%B6%E6%80%81">在 Vue 组件中获得 Vuex 状态<a class="anchor" href="#%E5%9C%A8-vue-%E7%BB%84%E4%BB%B6%E4%B8%AD%E8%8E%B7%E5%BE%97-vuex-%E7%8A%B6%E6%80%81">§</a></h2>\n<p>由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在<strong>计算属性</strong>中返回某个状态：</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 创建一个Counter组件</span>\n<span class="token keyword">const</span> <span class="token maybe-class-name">Counter</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n    template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div>{{ count }}&lt;/div></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>\n    computed<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token function">count</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword control-flow">return</span> store<span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">count</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>每当<code>store.state.count</code>变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。</p>\n<p>然而，这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态。</p>\n<p>Vuex 通过 <code>store</code> 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 <code>Vue.use(Vuex)</code>）：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    el<span class="token operator">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n    <span class="token comment">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span>\n    store<span class="token punctuation">,</span>\n    components<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token maybe-class-name">Counter</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">\n        &lt;div class="app">\n            &lt;Counter>&lt;/Counter>\n        &lt;/div>\n    </span><span class="token template-punctuation string">`</span></span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>通过在根实例中注册 <code>store</code> 选项，该 <code>store</code> 实例会注入到根组件下的所有子组件中，且子组件能通过 <code>this.$store</code> 访问到。让我们更新下 Counter 的实现：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">Counter</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n    template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div>{{ count }}&lt;/div></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>\n    computed<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token function">count</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$store</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">count</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h2 id="mapstate-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0">mapState 辅助函数<a class="anchor" href="#mapstate-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0">§</a></h2>\n<p>当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 <code>mapState</code> 辅助函数帮助我们生成计算属性，让你少按几次键：</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 在单独构建的版本中辅助函数为Vuex.mapState</span>\n<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> mapState <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">\'vuex\'</span>\n\n<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token punctuation">{</span>\n    <span class="token comment">// ...</span>\n    computed<span class="token operator">:</span> <span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n        <span class="token comment">// 箭头函数可使代码更简练</span>\n        <span class="token function-variable function">count</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token arrow operator">=></span> state<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">,</span>\n        <span class="token comment">// 传字符串参数 \'count\' 等同于 `state => state.count`</span>\n        countAlias<span class="token operator">:</span> <span class="token string">\'count\'</span><span class="token punctuation">,</span>\n        <span class="token comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span>\n        <span class="token function">countPlusLocalState</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword control-flow">return</span> state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">localCount</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>当映射的计算属性的名称与 <code>state</code> 的子节点名称相同时，我们也可以给 <code>mapState</code> 传一个字符串数组。</p>\n<pre class="language-js"><code class="language-js">computed<span class="token operator">:</span> <span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span>\n    <span class="token comment">// 映射 this.count 为 store.state.count</span>\n    <span class="token string">\'count\'</span>\n<span class="token punctuation">]</span><span class="token punctuation">)</span>\n</code></pre>\n<h2 id="%E5%AF%B9%E8%B1%A1%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6">对象展开运算符<a class="anchor" href="#%E5%AF%B9%E8%B1%A1%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6">§</a></h2>\n<p><code>mapState</code> 函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 <code>computed</code> 属性。但是自从有了对象展开运算符，我们可以极大地简化写法：</p>\n<pre class="language-js"><code class="language-js">computed<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">localComputed</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token comment">// 使用对象展开运算符将此对象混入到外部对象中</span>\n  <span class="token spread operator">...</span><span class="token method function property-access">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    <span class="token comment">// ...</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h1>Getter</h1>\n<p>有时候我们需要从 <code>store</code> 中的 <code>state</code> 中派生出一些状态，例如对列表进行过滤并计数：</p>\n<pre class="language-js"><code class="language-js">computed<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">doneTodosCount</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$store</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">todos</span><span class="token punctuation">.</span><span class="token method function property-access">filter</span><span class="token punctuation">(</span><span class="token parameter">todo</span> <span class="token arrow operator">=></span> todo<span class="token punctuation">.</span><span class="token property-access">done</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">length</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。</p>\n<p><code>Vuex</code> 允许我们在 <code>store</code> 中定义“<code>getter</code>”（可以认为是 store 的计算属性）。就像计算属性一样，<code>getter</code> 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>\n<p><code>Getter</code> 接受 <code>state</code> 作为其第一个参数：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  state<span class="token operator">:</span> <span class="token punctuation">{</span>\n    todos<span class="token operator">:</span> <span class="token punctuation">[</span>\n      <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> text<span class="token operator">:</span> <span class="token string">\'...\'</span><span class="token punctuation">,</span> done<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n      <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> text<span class="token operator">:</span> <span class="token string">\'...\'</span><span class="token punctuation">,</span> done<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  getters<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function-variable function">doneTodos</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n      <span class="token keyword control-flow">return</span> state<span class="token punctuation">.</span><span class="token property-access">todos</span><span class="token punctuation">.</span><span class="token method function property-access">filter</span><span class="token punctuation">(</span><span class="token parameter">todo</span> <span class="token arrow operator">=></span> todo<span class="token punctuation">.</span><span class="token property-access">done</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h2 id="%E9%80%9A%E8%BF%87%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE">通过属性访问<a class="anchor" href="#%E9%80%9A%E8%BF%87%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE">§</a></h2>\n<p>Getter 会暴露为 <code>store.getters</code> 对象，你可以以属性的形式访问这些值：</p>\n<pre class="language-js"><code class="language-js">store<span class="token punctuation">.</span><span class="token property-access">getters</span><span class="token punctuation">.</span><span class="token property-access">doneTodos</span> <span class="token comment">// -> [{ id: 1, text: \'...\', done: true }]</span>\n</code></pre>\n<p>Getter 也可以接受其他 <code>getter</code> 作为第二个参数：</p>\n<pre class="language-js"><code class="language-js">getters<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  <span class="token function-variable function">doneTodosCount</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> getters</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">return</span> getters<span class="token punctuation">.</span><span class="token property-access">doneTodos</span><span class="token punctuation">.</span><span class="token property-access">length</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\nstore<span class="token punctuation">.</span><span class="token property-access">getters</span><span class="token punctuation">.</span><span class="token property-access">doneTodosCount</span> <span class="token comment">// -> 1</span>\n</code></pre>\n<p>我们可以很容易地在任何组件中使用它：</p>\n<pre class="language-js"><code class="language-js">computed<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">doneTodosCount</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$store</span><span class="token punctuation">.</span><span class="token property-access">getters</span><span class="token punctuation">.</span><span class="token property-access">doneTodosCount</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>注意，getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。</p>\n<h2 id="%E9%80%9A%E8%BF%87%E6%96%B9%E6%B3%95%E8%AE%BF%E9%97%AE">通过方法访问<a class="anchor" href="#%E9%80%9A%E8%BF%87%E6%96%B9%E6%B3%95%E8%AE%BF%E9%97%AE">§</a></h2>\n<p>你也可以通过让 <code>getter</code> 返回一个函数，来实现给 <code>getter</code> 传参。在你对 <code>store</code> 里的数组进行查询时非常有用。</p>\n<pre class="language-js"><code class="language-js">getters<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  <span class="token function-variable function">getTodoById</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">return</span> state<span class="token punctuation">.</span><span class="token property-access">todos</span><span class="token punctuation">.</span><span class="token method function property-access">find</span><span class="token punctuation">(</span><span class="token parameter">todo</span> <span class="token arrow operator">=></span> todo<span class="token punctuation">.</span><span class="token property-access">id</span> <span class="token operator">===</span> id<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\nstore<span class="token punctuation">.</span><span class="token property-access">getters</span><span class="token punctuation">.</span><span class="token method function property-access">getTodoById</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// -> { id: 2, text: \'...\', done: false }</span>\n</code></pre>\n<p>注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。</p>\n<h2 id="mapgetters-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0">mapGetters 辅助函数<a class="anchor" href="#mapgetters-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0">§</a></h2>\n<p><code>mapGetters</code> 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> mapGetters <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">\'vuex\'</span>\n\n<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  computed<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span>\n    <span class="token spread operator">...</span><span class="token method function property-access">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span>\n      <span class="token string">\'doneTodosCount\'</span><span class="token punctuation">,</span>\n      <span class="token string">\'anotherGetter\'</span><span class="token punctuation">,</span>\n      <span class="token comment">// ...</span>\n    <span class="token punctuation">]</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>如果你想将一个 getter 属性另取一个名字，使用对象形式：</p>\n<pre class="language-js"><code class="language-js"><span class="token spread operator">...</span><span class="token method function property-access">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token comment">// 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`</span>\n  doneCount<span class="token operator">:</span> <span class="token string">\'doneTodosCount\'</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h1>Mutation</h1>\n<p>更改 Vuex 的 store 中的状态的唯一方法是<code>提交 mutation</code>。Vuex 中的 <code>mutation</code> 非常类似于事件：每个 <code>mutation</code> 都有一个字符串的 <code>事件类型 (type)</code> 和 一个 <code>回调函数 (handler)</code>。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  state<span class="token operator">:</span> <span class="token punctuation">{</span>\n    count<span class="token operator">:</span> <span class="token number">1</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  mutations<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 变更状态</span>\n      state<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token operator">++</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>你不能直接调用一个 <code>mutation handler</code>。这个选项更像是事件注册：“当触发一个类型为 <code>increment</code> 的 <code>mutation</code> 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 <code>type</code> 调用 <code>store.commit</code> 方法：</p>\n<pre class="language-js"><code class="language-js">store<span class="token punctuation">.</span><span class="token method function property-access">commit</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">)</span>\n</code></pre>\n<h2 id="%E6%8F%90%E4%BA%A4%E8%BD%BD%E8%8D%B7payload">提交载荷（Payload）<a class="anchor" href="#%E6%8F%90%E4%BA%A4%E8%BD%BD%E8%8D%B7payload">§</a></h2>\n<p>你可以向 <code>store.commit</code> 传入额外的参数，即 <code>mutation</code> 的 载荷（payload）：</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// ...</span>\nmutations<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">+=</span> n\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\nstore<span class="token punctuation">.</span><span class="token method function property-access">commit</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>\n</code></pre>\n<p>在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// ...</span>\nmutations<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">+=</span> payload<span class="token punctuation">.</span><span class="token property-access">amount</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\nstore<span class="token punctuation">.</span><span class="token method function property-access">commit</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  amount<span class="token operator">:</span> <span class="token number">10</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h2 id="%E5%AF%B9%E8%B1%A1%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F">对象风格的提交方式<a class="anchor" href="#%E5%AF%B9%E8%B1%A1%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F">§</a></h2>\n<p>提交 <code>mutation</code> 的另一种方式是直接使用包含 <code>type</code> 属性的对象：</p>\n<pre class="language-js"><code class="language-js">store<span class="token punctuation">.</span><span class="token method function property-access">commit</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  type<span class="token operator">:</span> <span class="token string">\'increment\'</span><span class="token punctuation">,</span>\n  amount<span class="token operator">:</span> <span class="token number">10</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>当使用对象风格的提交方式，整个对象都作为载荷传给 <code>mutation</code> 函数，因此 <code>handler</code> 保持不变：</p>\n<pre class="language-js"><code class="language-js">mutations<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">+=</span> payload<span class="token punctuation">.</span><span class="token property-access">amount</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h2 id="mutation-%E9%9C%80%E9%81%B5%E5%AE%88-vue-%E7%9A%84%E5%93%8D%E5%BA%94%E8%A7%84%E5%88%99">Mutation 需遵守 Vue 的响应规则<a class="anchor" href="#mutation-%E9%9C%80%E9%81%B5%E5%AE%88-vue-%E7%9A%84%E5%93%8D%E5%BA%94%E8%A7%84%E5%88%99">§</a></h2>\n<p>既然 <code>Vuex</code> 的 <code>store</code> 中的状态是响应式的，那么当我们变更状态时，监视状态的 <code>Vue</code> 组件也会自动更新。这也意味着 <code>Vuex</code> 中的 <code>mutation</code> 也需要与使用 <code>Vue</code> 一样遵守一些注意事项：</p>\n<ol>\n<li>\n<p>最好提前在你的 <code>store</code> 中初始化好所有所需属性。</p>\n</li>\n<li>\n<p>当需要在对象上添加新属性时，你应该:</p>\n<ol>\n<li>使用 <code>Vue.set(obj, \'newProp\', 123)</code>, 或者</li>\n<li>以新对象替换老对象。例如，利用对象展开运算符,我们可以这样写：</li>\n</ol>\n<pre class="language-js"><code class="language-js">state<span class="token punctuation">.</span><span class="token property-access">obj</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span>state<span class="token punctuation">.</span><span class="token property-access">obj</span><span class="token punctuation">,</span> newProp<span class="token operator">:</span> <span class="token number">123</span> <span class="token punctuation">}</span>\n</code></pre>\n</li>\n</ol>\n<h2 id="%E4%BD%BF%E7%94%A8%E5%B8%B8%E9%87%8F%E6%9B%BF%E4%BB%A3-mutation-%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B">使用常量替代 Mutation 事件类型<a class="anchor" href="#%E4%BD%BF%E7%94%A8%E5%B8%B8%E9%87%8F%E6%9B%BF%E4%BB%A3-mutation-%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B">§</a></h2>\n<p>使用常量替代 <code>mutation</code> 事件类型在各种 <code>Flux</code> 实现中是很常见的模式。这样可以使 <code>linter</code> 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 <code>app</code> 包含的 <code>mutation</code> 一目了然：</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// mutation-types.js</span>\n<span class="token keyword module">export</span> <span class="token keyword">const</span> <span class="token constant">SOME_MUTATION</span> <span class="token operator">=</span> <span class="token string">\'SOME_MUTATION\'</span>\n\n<span class="token comment">// store.js</span>\n<span class="token comment">// store.js</span>\n<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">Vuex</span></span> <span class="token keyword module">from</span> <span class="token string">\'vuex\'</span>\n<span class="token keyword module">import</span> <span class="token punctuation">{</span> <span class="token constant">SOME_MUTATION</span> <span class="token punctuation">}</span> <span class="token keyword module">from</span> <span class="token string">\'./mutation-types\'</span>\n\n<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  state<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  mutations<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span>\n    <span class="token punctuation">[</span><span class="token constant">SOME_MUTATION</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// mutate state</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做</p>\n<h2 id="mutation-%E5%BF%85%E9%A1%BB%E6%98%AF%E5%90%8C%E6%AD%A5%E5%87%BD%E6%95%B0">Mutation 必须是同步函数<a class="anchor" href="#mutation-%E5%BF%85%E9%A1%BB%E6%98%AF%E5%90%8C%E6%AD%A5%E5%87%BD%E6%95%B0">§</a></h2>\n<p>一条重要的原则就是要记住 mutation 必须是同步函数。为什么？请参考下面的例子：</p>\n<pre class="language-js"><code class="language-js">mutations<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">someMutation</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    api<span class="token punctuation">.</span><span class="token method function property-access">callAsyncMethod</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n      state<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token operator">++</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>现在想象，我们正在 <code>debug</code> 一个 <code>app</code> 并且观察 <code>devtool</code> 中的 <code>mutation</code> 日志。每一条 <code>mutation</code> <code>被记录，devtools</code> 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 <code>mutation</code> 中的异步函数中的回调让这不可能完成：因为当 <code>mutation</code> 触发的时候，回调函数还没有被调用， <code>devtools</code> 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。</p>\n<h2 id="%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%8F%90%E4%BA%A4-mutation">在组件中提交 Mutation<a class="anchor" href="#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%8F%90%E4%BA%A4-mutation">§</a></h2>\n<p>你可以在组件中使用 <code>this.$store.commit(\'xxx\')</code> <code>提交 mutation</code>，或者使用 <code>mapMutations</code> 辅助函数将组件中的 <code>methods</code> 映射为 <code>store.commit</code> 调用（需要在根节点注入 store）。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> mapMutations <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">\'vuex\'</span>\n\n<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  methods<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token spread operator">...</span><span class="token method function property-access">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">[</span>\n      <span class="token string">\'increment\'</span><span class="token punctuation">,</span> <span class="token comment">// 将 `this.increment()` 映射为 `this.$store.commit(\'increment\')`</span>\n\n      <span class="token comment">// `mapMutations` 也支持载荷：</span>\n      <span class="token string">\'incrementBy\'</span> <span class="token comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(\'incrementBy\', amount)`</span>\n    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token spread operator">...</span><span class="token method function property-access">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      add<span class="token operator">:</span> <span class="token string">\'increment\'</span> <span class="token comment">// 将 `this.add()` 映射为 `this.$store.commit(\'increment\')`</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h1>Actions</h1>\n<p><code>Action</code> 类似于 <code>mutation</code>，不同在于：</p>\n<ol>\n<li>Action 提交的是 mutation，而不是直接变更状态。</li>\n<li>Action 可以包含任意异步操作。</li>\n</ol>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  state<span class="token operator">:</span> <span class="token punctuation">{</span>\n    count<span class="token operator">:</span> <span class="token number">0</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  mutations<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      state<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token operator">++</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  actions<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      context<span class="token punctuation">.</span><span class="token method function property-access">commit</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p><code>Action</code> 函数接受一个与 <code>store</code> 实例具有相同方法和属性的 <code>context</code> 对象，因此你可以调用 <code>context.commit</code> 提交一个 <code>mutation</code>，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 <code>state</code> 和 <code>getters</code>。当我们在之后介绍到 <code>Modules</code> 时，你就知道 <code>context</code> 对象为什么不是 <code>store</code> 实例本身了。</p>\n<p>实践中，我们会经常用到 <code>ES2015</code> 的 <code>参数解构</code> 来简化代码（特别是我们需要调用 <code>commit</code> 很多次的时候）：</p>\n<pre class="language-js"><code class="language-js">actions<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> commit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h2 id="%E5%88%86%E5%8F%91-action">分发 Action<a class="anchor" href="#%E5%88%86%E5%8F%91-action">§</a></h2>\n<p><code>Action</code> 通过 <code>store.dispatch</code> 方法触发：</p>\n<pre class="language-js"><code class="language-js">store<span class="token punctuation">.</span><span class="token method function property-access">dispatch</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">)</span>\n</code></pre>\n<p>乍一眼看上去感觉多此一举，我们直接分发 <code>mutation</code> 岂不更方便？实际上并非如此，还记得 <code>mutation</code> 必须同步执行这个限制么？<code>Action</code> 就不受约束！我们可以在 <code>action</code> 内部执行异步操作：</p>\n<pre class="language-js"><code class="language-js">actions<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">incrementAsync</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> commit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n      <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p><code>Actions</code> 支持同样的载荷方式和对象方式进行分发：</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 以载荷形式分发</span>\nstore<span class="token punctuation">.</span><span class="token method function property-access">dispatch</span><span class="token punctuation">(</span><span class="token string">\'incrementAsync\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  amount<span class="token operator">:</span> <span class="token number">10</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 以对象形式分发</span>\nstore<span class="token punctuation">.</span><span class="token method function property-access">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  type<span class="token operator">:</span> <span class="token string">\'incrementAsync\'</span><span class="token punctuation">,</span>\n  amount<span class="token operator">:</span> <span class="token number">10</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>来看一个更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation：</p>\n<pre class="language-js"><code class="language-js">actions<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">checkout</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> commit<span class="token punctuation">,</span> state <span class="token punctuation">}</span><span class="token punctuation">,</span> products</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 备份当前购物车的物品</span>\n        <span class="token keyword">const</span> savedCartItems <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token spread operator">...</span>state<span class="token punctuation">.</span><span class="token property-access">cart</span><span class="token punctuation">.</span><span class="token property-access">added</span><span class="token punctuation">]</span>\n        <span class="token comment">// 发出结账请求，然后清空购物车</span>\n        <span class="token function">commit</span><span class="token punctuation">(</span>types<span class="token punctuation">.</span><span class="token constant">CHECKOUT_REQUEST</span><span class="token punctuation">)</span>\n        <span class="token comment">// 购物API接受一个成功回调和一个失败回调</span>\n        shop<span class="token punctuation">.</span><span class="token method function property-access">buyProducts</span><span class="token punctuation">(</span>products<span class="token punctuation">,</span>\n            <span class="token comment">// 成功操作</span>\n            <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">commit</span><span class="token punctuation">(</span>types<span class="token punctuation">.</span><span class="token constant">CHECKOUT_SUCCESS</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n            <span class="token comment">// 失败操作</span>\n            <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">commit</span><span class="token punctuation">(</span>types<span class="token punctuation">.</span><span class="token constant">CHECKOUT_FAILURE</span><span class="token punctuation">,</span> savedCartItems<span class="token punctuation">)</span>\n        <span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>注意我们正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）。</p>\n<h2 id="%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%88%86%E5%8F%91-action">在组件中分发 Action<a class="anchor" href="#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%88%86%E5%8F%91-action">§</a></h2>\n<p>你在组件中使用 <code>this.$store.dispatch(\'xxx\')</code> 分发 action，或者使用 <code>mapActions</code> 辅助函数将组件的 <code>methods</code> 映射为 <code>store.dispatch</code> 调用（需要先在根节点注入 store）：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> mapActions <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">\'vuex\'</span>\n\n<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  methods<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token spread operator">...</span><span class="token method function property-access">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span>\n      <span class="token string">\'increment\'</span><span class="token punctuation">,</span> <span class="token comment">// 将 `this.increment()` 映射为 `this.$store.dispatch(\'increment\')`</span>\n\n      <span class="token comment">// `mapActions` 也支持载荷：</span>\n      <span class="token string">\'incrementBy\'</span> <span class="token comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(\'incrementBy\', amount)`</span>\n    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token spread operator">...</span><span class="token method function property-access">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      add<span class="token operator">:</span> <span class="token string">\'increment\'</span> <span class="token comment">// 将 `this.add()` 映射为 `this.$store.dispatch(\'increment\')`</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h2 id="%E7%BB%84%E5%90%88-action">组合 Action<a class="anchor" href="#%E7%BB%84%E5%90%88-action">§</a></h2>\n<p><code>Action</code> 通常是异步的，那么如何知道 <code>action</code> 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p>\n<p>首先，你需要明白 <code>store.dispatch</code> 可以处理被触发的 <code>action</code> 的处理函数返回的 <code>Promise</code>，并且 <code>store.dispatch</code> 仍旧返回 <code>Promise</code>：</p>\n<pre class="language-js"><code class="language-js">actions<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">actionA</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> commit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n        <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'someMutation\'</span><span class="token punctuation">)</span>\n        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>现在你可以：</p>\n<pre class="language-js"><code class="language-js">store<span class="token punctuation">.</span><span class="token method function property-access">dispatch</span><span class="token punctuation">(</span><span class="token string">\'actionA\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>在另外一个 action 中也可以：</p>\n<pre class="language-js"><code class="language-js">actions<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  <span class="token function">actionB</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> dispatch<span class="token punctuation">,</span> commit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">return</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">\'actionA\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n      <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'someOtherMutation\'</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>最后，如果我们利用 <code>async / await</code> ，我们可以如下组合 action：</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span>\n\nactions<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token keyword">async</span> <span class="token function">actionA</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> commit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'gotData\'</span><span class="token punctuation">,</span> <span class="token keyword control-flow">await</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token keyword">async</span> <span class="token function">actionB</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> dispatch<span class="token punctuation">,</span> commit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">await</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">\'actionA\'</span><span class="token punctuation">)</span> <span class="token comment">// 等待 actionA 完成</span>\n    <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'gotOtherData\'</span><span class="token punctuation">,</span> <span class="token keyword control-flow">await</span> <span class="token function">getOtherData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>一个 <code>store.dispatch </code>在不同模块中可以触发多个 <code>action</code> 函数。在这种情况下，只有当所有触发函数完成后，返回的 <code>Promise</code> 才会执行。</p>\n<h1>Module</h1>\n<p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p>\n<p>为了解决以上问题，Vuex 允许我们将 store 分割成<code>模块（module）</code>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">state</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  mutations<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  actions<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  getters<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> moduleB <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">state</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  mutations<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  actions<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  modules<span class="token operator">:</span> <span class="token punctuation">{</span>\n    a<span class="token operator">:</span> moduleA<span class="token punctuation">,</span>\n    b<span class="token operator">:</span> moduleB\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\nstore<span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">a</span> <span class="token comment">// -> moduleA 的状态</span>\nstore<span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">b</span> <span class="token comment">// -> moduleB 的状态</span>\n</code></pre>\n<h2 id="%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B1%80%E9%83%A8%E7%8A%B6%E6%80%81">模块的局部状态<a class="anchor" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B1%80%E9%83%A8%E7%8A%B6%E6%80%81">§</a></h2>\n<p>对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">state</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>\n    count<span class="token operator">:</span> <span class="token number">0</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  mutations<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 这里的 `state` 对象是模块的局部状态</span>\n      state<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token operator">++</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n  getters<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">doubleCount</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword control-flow">return</span> state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">*</span> <span class="token number">2</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>同样，对于模块内部的 action，局部状态通过 <code>context.state</code> 暴露出来，根节点状态则为 <code>context.rootState</code>：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  actions<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">incrementIfOddOnRootSum</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> state<span class="token punctuation">,</span> commit<span class="token punctuation">,</span> rootState <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">+</span> rootState<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">)</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  getters<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">sumWithRootCount</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> getters<span class="token punctuation">,</span> rootState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword control-flow">return</span> state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">+</span> rootState<span class="token punctuation">.</span><span class="token property-access">count</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h2 id="%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">命名空间<a class="anchor" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">§</a></h2>\n<p>默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。</p>\n<p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  modules<span class="token operator">:</span> <span class="token punctuation">{</span>\n    account<span class="token operator">:</span> <span class="token punctuation">{</span>\n      namespaced<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n\n      <span class="token comment">// 模块内容（module assets）</span>\n      <span class="token function-variable function">state</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span>\n      getters<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token function">isAdmin</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span> <span class="token comment">// -> getters[\'account/isAdmin\']</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span>\n      actions<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token function">login</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span> <span class="token comment">// -> dispatch(\'account/login\')</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span>\n      mutations<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token function">login</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span> <span class="token comment">// -> commit(\'account/login\')</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n      <span class="token comment">// 嵌套模块</span>\n      modules<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 继承父模块的命名空间</span>\n        myPage<span class="token operator">:</span> <span class="token punctuation">{</span>\n          <span class="token function-variable function">state</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n          getters<span class="token operator">:</span> <span class="token punctuation">{</span>\n            <span class="token function">profile</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span> <span class="token comment">// -> getters[\'account/profile\']</span>\n          <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n        <span class="token comment">// 进一步嵌套命名空间</span>\n        posts<span class="token operator">:</span> <span class="token punctuation">{</span>\n          namespaced<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n\n          <span class="token function-variable function">state</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n          getters<span class="token operator">:</span> <span class="token punctuation">{</span>\n            <span class="token function">popular</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span> <span class="token comment">// -> getters[\'account/posts/popular\']</span>\n          <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>启用了命名空间的 getter 和 action 会收到局部化的 getter，dispatch 和 commit。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 namespaced 属性后不需要修改模块内的代码</p>\n<h2 id="%E5%9C%A8%E5%B8%A6%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%86%8C%E5%85%A8%E5%B1%80-action">在带命名空间的模块注册全局 action<a class="anchor" href="#%E5%9C%A8%E5%B8%A6%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%86%8C%E5%85%A8%E5%B1%80-action">§</a></h2>\n<p>若需要在带命名空间的模块注册全局 action，你可添加 root: true，并将这个 action 的定义放在函数 handler 中。例如：</p>\n<pre class="language-js"><code class="language-js"><span class="token punctuation">{</span>\n  actions<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">someOtherAction</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>dispatch<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">\'someAction\'</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  modules<span class="token operator">:</span> <span class="token punctuation">{</span>\n    foo<span class="token operator">:</span> <span class="token punctuation">{</span>\n      namespaced<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n\n      actions<span class="token operator">:</span> <span class="token punctuation">{</span>\n        someAction<span class="token operator">:</span> <span class="token punctuation">{</span>\n          root<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n          <span class="token function">handler</span> <span class="token punctuation">(</span><span class="token parameter">namespacedContext<span class="token punctuation">,</span> payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span> <span class="token comment">// -> \'someAction\'</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h2 id="%E5%B8%A6%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E7%BB%91%E5%AE%9A%E5%87%BD%E6%95%B0">带命名空间的绑定函数<a class="anchor" href="#%E5%B8%A6%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E7%BB%91%E5%AE%9A%E5%87%BD%E6%95%B0">§</a></h2>\n<p>当使用 mapState, mapGetters, mapActions 和 mapMutations 这些函数来绑定带命名空间的模块时，写起来可能比较繁琐：</p>\n<pre class="language-js"><code class="language-js">computed<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token spread operator">...</span><span class="token method function property-access">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token arrow operator">=></span> state<span class="token punctuation">.</span><span class="token property-access">some</span><span class="token punctuation">.</span><span class="token property-access">nested</span><span class="token punctuation">.</span><span class="token property-access">module</span><span class="token punctuation">.</span><span class="token property-access">a</span><span class="token punctuation">,</span>\n    <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token arrow operator">=></span> state<span class="token punctuation">.</span><span class="token property-access">some</span><span class="token punctuation">.</span><span class="token property-access">nested</span><span class="token punctuation">.</span><span class="token property-access">module</span><span class="token punctuation">.</span><span class="token property-access">b</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\nmethods<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token spread operator">...</span><span class="token method function property-access">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span>\n    <span class="token string">\'some/nested/module/foo\'</span><span class="token punctuation">,</span> <span class="token comment">// -> this[\'some/nested/module/foo\']()</span>\n    <span class="token string">\'some/nested/module/bar\'</span> <span class="token comment">// -> this[\'some/nested/module/bar\']()</span>\n  <span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>对于这种情况，你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。于是上面的例子可以简化为：</p>\n<pre class="language-js"><code class="language-js">computed<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token spread operator">...</span><span class="token method function property-access">mapState</span><span class="token punctuation">(</span><span class="token string">\'some/nested/module\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n    <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token arrow operator">=></span> state<span class="token punctuation">.</span><span class="token property-access">a</span><span class="token punctuation">,</span>\n    <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token arrow operator">=></span> state<span class="token punctuation">.</span><span class="token property-access">b</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\nmethods<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token spread operator">...</span><span class="token method function property-access">mapActions</span><span class="token punctuation">(</span><span class="token string">\'some/nested/module\'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>\n    <span class="token string">\'foo\'</span><span class="token punctuation">,</span> <span class="token comment">// -> this.foo()</span>\n    <span class="token string">\'bar\'</span> <span class="token comment">// -> this.bar()</span>\n  <span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>而且，你可以通过使用 createNamespacedHelpers 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> createNamespacedHelpers <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">\'vuex\'</span>\n\n<span class="token keyword">const</span> <span class="token punctuation">{</span> mapState<span class="token punctuation">,</span> mapActions <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createNamespacedHelpers</span><span class="token punctuation">(</span><span class="token string">\'some/nested/module\'</span><span class="token punctuation">)</span>\n\n<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token punctuation">{</span>\n  computed<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 在 `some/nested/module` 中查找</span>\n    <span class="token spread operator">...</span><span class="token method function property-access">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token arrow operator">=></span> state<span class="token punctuation">.</span><span class="token property-access">a</span><span class="token punctuation">,</span>\n      <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token arrow operator">=></span> state<span class="token punctuation">.</span><span class="token property-access">b</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  methods<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 在 `some/nested/module` 中查找</span>\n    <span class="token spread operator">...</span><span class="token method function property-access">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span>\n      <span class="token string">\'foo\'</span><span class="token punctuation">,</span>\n      <span class="token string">\'bar\'</span>\n    <span class="token punctuation">]</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h2 id="%E6%A8%A1%E5%9D%97%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C">模块动态注册<a class="anchor" href="#%E6%A8%A1%E5%9D%97%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C">§</a></h2>\n<p>在 store 创建之后，你可以使用 store.registerModule 方法注册模块：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">Vuex</span></span> <span class="token keyword module">from</span> <span class="token string">\'vuex\'</span>\n\n<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token comment">/* 选项 */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 注册模块 `myModule`</span>\nstore<span class="token punctuation">.</span><span class="token method function property-access">registerModule</span><span class="token punctuation">(</span><span class="token string">\'myModule\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token comment">// 注册嵌套模块 `nested/myModule`</span>\nstore<span class="token punctuation">.</span><span class="token method function property-access">registerModule</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">\'nested\'</span><span class="token punctuation">,</span> <span class="token string">\'myModule\'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>之后就可以通过 <code>store.state.myModule</code> 和 <code>store.state.nested.myModule</code> 访问模块的状态。</p>'
        } }),
    'head': React.createElement("link", { href: "/favicon.png", rel: "icon", type: "image/png" }),
    'script': React.createElement(React.Fragment, null,
        React.createElement("script", { src: "https://cdn.pagic.org/react@16.13.1/umd/react.production.min.js" }),
        React.createElement("script", { src: "https://cdn.pagic.org/react-dom@16.13.1/umd/react-dom.production.min.js" }),
        React.createElement("script", { src: "/index.js", type: "module" })),
    'contentTitle': React.createElement("h1", { key: "0" }, "Vuex"),
    'contentBody': React.createElement("article", { dangerouslySetInnerHTML: {
            __html: '<p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>\n<p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的<strong>状态 (state)</strong>。Vuex 和单纯的全局对象有以下两点不同：</p>\n<ol>\n<li>\n<p>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p>\n</li>\n<li>\n<p>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地<strong>提交 (commit) mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</p>\n</li>\n</ol>\n<h1>最简单的 Store</h1>\n<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">Vue</span></span> <span class="token keyword module">from</span> <span class="token string">\'vue\'</span>\n<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">Vuex</span></span> <span class="token keyword module">from</span> <span class="token string">\'vuex\'</span>\n\n<span class="token maybe-class-name">Vue</span><span class="token punctuation">.</span><span class="token method function property-access">use</span><span class="token punctuation">(</span><span class="token maybe-class-name">Vuex</span><span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    state<span class="token operator">:</span> <span class="token punctuation">{</span>\n        count<span class="token operator">:</span> <span class="token number">0</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    mutations<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            state<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token operator">++</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 现在，你可以通过 store.state 来获取状态对象，以及通过 store.commit 方法触发状态变更：</span>\nstore<span class="token punctuation">.</span><span class="token method function property-access">commit</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">)</span>\n\n<span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span>store<span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>\n\n<span class="token comment">// 为了在 Vue 组件中访问 this.$store property，你需要为 Vue 实例提供创建好的 store。Vuex 提供了一个从根组件向所有子组件，以 store 选项的方式“注入”该 store 的机制：</span>\n<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    el<span class="token operator">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n    store<span class="token operator">:</span> store\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 如果使用 ES6，你也可以以 ES6 对象的 property 简写 (用在对象某个 property 的 key 和被传入的变量同名时)：</span>\n\n<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  el<span class="token operator">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n  store\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 现在我们可以从组件的方法提交一个变更：</span>\nmethods<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$store</span><span class="token punctuation">.</span><span class="token method function property-access">commit</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">)</span>\n        <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$store</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p><em>再次强调，我们通过提交 mutation 的方式，而非直接改变 store.state.count，是因为我们想要更明确地追踪到状态的变化。</em></p>\n<p>由于 store 中的状态是响应式的，在组件中调用 store 中的状态简单到仅需要在<strong>计算属性</strong>中返回即可。触发变化也仅仅是在组件的 <strong>methods 中提交 mutation</strong>。</p>\n<h1>state</h1>\n<h2 id="%E5%8D%95%E4%B8%80%E7%8A%B6%E6%80%81%E6%A0%91">单一状态树<a class="anchor" href="#%E5%8D%95%E4%B8%80%E7%8A%B6%E6%80%81%E6%A0%91">§</a></h2>\n<p>Vuex 使用<strong>单一状态树</strong>——是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。</p>\n<h2 id="%E5%9C%A8-vue-%E7%BB%84%E4%BB%B6%E4%B8%AD%E8%8E%B7%E5%BE%97-vuex-%E7%8A%B6%E6%80%81">在 Vue 组件中获得 Vuex 状态<a class="anchor" href="#%E5%9C%A8-vue-%E7%BB%84%E4%BB%B6%E4%B8%AD%E8%8E%B7%E5%BE%97-vuex-%E7%8A%B6%E6%80%81">§</a></h2>\n<p>由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在<strong>计算属性</strong>中返回某个状态：</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 创建一个Counter组件</span>\n<span class="token keyword">const</span> <span class="token maybe-class-name">Counter</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n    template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div>{{ count }}&lt;/div></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>\n    computed<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token function">count</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword control-flow">return</span> store<span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">count</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>每当<code>store.state.count</code>变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。</p>\n<p>然而，这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态。</p>\n<p>Vuex 通过 <code>store</code> 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 <code>Vue.use(Vuex)</code>）：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    el<span class="token operator">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n    <span class="token comment">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span>\n    store<span class="token punctuation">,</span>\n    components<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token maybe-class-name">Counter</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">\n        &lt;div class="app">\n            &lt;Counter>&lt;/Counter>\n        &lt;/div>\n    </span><span class="token template-punctuation string">`</span></span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>通过在根实例中注册 <code>store</code> 选项，该 <code>store</code> 实例会注入到根组件下的所有子组件中，且子组件能通过 <code>this.$store</code> 访问到。让我们更新下 Counter 的实现：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">Counter</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n    template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div>{{ count }}&lt;/div></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>\n    computed<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token function">count</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$store</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">count</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h2 id="mapstate-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0">mapState 辅助函数<a class="anchor" href="#mapstate-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0">§</a></h2>\n<p>当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 <code>mapState</code> 辅助函数帮助我们生成计算属性，让你少按几次键：</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 在单独构建的版本中辅助函数为Vuex.mapState</span>\n<span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> mapState <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">\'vuex\'</span>\n\n<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token punctuation">{</span>\n    <span class="token comment">// ...</span>\n    computed<span class="token operator">:</span> <span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n        <span class="token comment">// 箭头函数可使代码更简练</span>\n        <span class="token function-variable function">count</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token arrow operator">=></span> state<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">,</span>\n        <span class="token comment">// 传字符串参数 \'count\' 等同于 `state => state.count`</span>\n        countAlias<span class="token operator">:</span> <span class="token string">\'count\'</span><span class="token punctuation">,</span>\n        <span class="token comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span>\n        <span class="token function">countPlusLocalState</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword control-flow">return</span> state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">localCount</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>当映射的计算属性的名称与 <code>state</code> 的子节点名称相同时，我们也可以给 <code>mapState</code> 传一个字符串数组。</p>\n<pre class="language-js"><code class="language-js">computed<span class="token operator">:</span> <span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span>\n    <span class="token comment">// 映射 this.count 为 store.state.count</span>\n    <span class="token string">\'count\'</span>\n<span class="token punctuation">]</span><span class="token punctuation">)</span>\n</code></pre>\n<h2 id="%E5%AF%B9%E8%B1%A1%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6">对象展开运算符<a class="anchor" href="#%E5%AF%B9%E8%B1%A1%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6">§</a></h2>\n<p><code>mapState</code> 函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 <code>computed</code> 属性。但是自从有了对象展开运算符，我们可以极大地简化写法：</p>\n<pre class="language-js"><code class="language-js">computed<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">localComputed</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token comment">// 使用对象展开运算符将此对象混入到外部对象中</span>\n  <span class="token spread operator">...</span><span class="token method function property-access">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    <span class="token comment">// ...</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h1>Getter</h1>\n<p>有时候我们需要从 <code>store</code> 中的 <code>state</code> 中派生出一些状态，例如对列表进行过滤并计数：</p>\n<pre class="language-js"><code class="language-js">computed<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">doneTodosCount</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$store</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">todos</span><span class="token punctuation">.</span><span class="token method function property-access">filter</span><span class="token punctuation">(</span><span class="token parameter">todo</span> <span class="token arrow operator">=></span> todo<span class="token punctuation">.</span><span class="token property-access">done</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">length</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。</p>\n<p><code>Vuex</code> 允许我们在 <code>store</code> 中定义“<code>getter</code>”（可以认为是 store 的计算属性）。就像计算属性一样，<code>getter</code> 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>\n<p><code>Getter</code> 接受 <code>state</code> 作为其第一个参数：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  state<span class="token operator">:</span> <span class="token punctuation">{</span>\n    todos<span class="token operator">:</span> <span class="token punctuation">[</span>\n      <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> text<span class="token operator">:</span> <span class="token string">\'...\'</span><span class="token punctuation">,</span> done<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n      <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> text<span class="token operator">:</span> <span class="token string">\'...\'</span><span class="token punctuation">,</span> done<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  getters<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function-variable function">doneTodos</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n      <span class="token keyword control-flow">return</span> state<span class="token punctuation">.</span><span class="token property-access">todos</span><span class="token punctuation">.</span><span class="token method function property-access">filter</span><span class="token punctuation">(</span><span class="token parameter">todo</span> <span class="token arrow operator">=></span> todo<span class="token punctuation">.</span><span class="token property-access">done</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h2 id="%E9%80%9A%E8%BF%87%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE">通过属性访问<a class="anchor" href="#%E9%80%9A%E8%BF%87%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE">§</a></h2>\n<p>Getter 会暴露为 <code>store.getters</code> 对象，你可以以属性的形式访问这些值：</p>\n<pre class="language-js"><code class="language-js">store<span class="token punctuation">.</span><span class="token property-access">getters</span><span class="token punctuation">.</span><span class="token property-access">doneTodos</span> <span class="token comment">// -> [{ id: 1, text: \'...\', done: true }]</span>\n</code></pre>\n<p>Getter 也可以接受其他 <code>getter</code> 作为第二个参数：</p>\n<pre class="language-js"><code class="language-js">getters<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  <span class="token function-variable function">doneTodosCount</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> getters</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">return</span> getters<span class="token punctuation">.</span><span class="token property-access">doneTodos</span><span class="token punctuation">.</span><span class="token property-access">length</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\nstore<span class="token punctuation">.</span><span class="token property-access">getters</span><span class="token punctuation">.</span><span class="token property-access">doneTodosCount</span> <span class="token comment">// -> 1</span>\n</code></pre>\n<p>我们可以很容易地在任何组件中使用它：</p>\n<pre class="language-js"><code class="language-js">computed<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">doneTodosCount</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$store</span><span class="token punctuation">.</span><span class="token property-access">getters</span><span class="token punctuation">.</span><span class="token property-access">doneTodosCount</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>注意，getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。</p>\n<h2 id="%E9%80%9A%E8%BF%87%E6%96%B9%E6%B3%95%E8%AE%BF%E9%97%AE">通过方法访问<a class="anchor" href="#%E9%80%9A%E8%BF%87%E6%96%B9%E6%B3%95%E8%AE%BF%E9%97%AE">§</a></h2>\n<p>你也可以通过让 <code>getter</code> 返回一个函数，来实现给 <code>getter</code> 传参。在你对 <code>store</code> 里的数组进行查询时非常有用。</p>\n<pre class="language-js"><code class="language-js">getters<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  <span class="token function-variable function">getTodoById</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">return</span> state<span class="token punctuation">.</span><span class="token property-access">todos</span><span class="token punctuation">.</span><span class="token method function property-access">find</span><span class="token punctuation">(</span><span class="token parameter">todo</span> <span class="token arrow operator">=></span> todo<span class="token punctuation">.</span><span class="token property-access">id</span> <span class="token operator">===</span> id<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\nstore<span class="token punctuation">.</span><span class="token property-access">getters</span><span class="token punctuation">.</span><span class="token method function property-access">getTodoById</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// -> { id: 2, text: \'...\', done: false }</span>\n</code></pre>\n<p>注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。</p>\n<h2 id="mapgetters-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0">mapGetters 辅助函数<a class="anchor" href="#mapgetters-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0">§</a></h2>\n<p><code>mapGetters</code> 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> mapGetters <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">\'vuex\'</span>\n\n<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  computed<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span>\n    <span class="token spread operator">...</span><span class="token method function property-access">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span>\n      <span class="token string">\'doneTodosCount\'</span><span class="token punctuation">,</span>\n      <span class="token string">\'anotherGetter\'</span><span class="token punctuation">,</span>\n      <span class="token comment">// ...</span>\n    <span class="token punctuation">]</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>如果你想将一个 getter 属性另取一个名字，使用对象形式：</p>\n<pre class="language-js"><code class="language-js"><span class="token spread operator">...</span><span class="token method function property-access">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token comment">// 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`</span>\n  doneCount<span class="token operator">:</span> <span class="token string">\'doneTodosCount\'</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h1>Mutation</h1>\n<p>更改 Vuex 的 store 中的状态的唯一方法是<code>提交 mutation</code>。Vuex 中的 <code>mutation</code> 非常类似于事件：每个 <code>mutation</code> 都有一个字符串的 <code>事件类型 (type)</code> 和 一个 <code>回调函数 (handler)</code>。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  state<span class="token operator">:</span> <span class="token punctuation">{</span>\n    count<span class="token operator">:</span> <span class="token number">1</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  mutations<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 变更状态</span>\n      state<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token operator">++</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>你不能直接调用一个 <code>mutation handler</code>。这个选项更像是事件注册：“当触发一个类型为 <code>increment</code> 的 <code>mutation</code> 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 <code>type</code> 调用 <code>store.commit</code> 方法：</p>\n<pre class="language-js"><code class="language-js">store<span class="token punctuation">.</span><span class="token method function property-access">commit</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">)</span>\n</code></pre>\n<h2 id="%E6%8F%90%E4%BA%A4%E8%BD%BD%E8%8D%B7payload">提交载荷（Payload）<a class="anchor" href="#%E6%8F%90%E4%BA%A4%E8%BD%BD%E8%8D%B7payload">§</a></h2>\n<p>你可以向 <code>store.commit</code> 传入额外的参数，即 <code>mutation</code> 的 载荷（payload）：</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// ...</span>\nmutations<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">+=</span> n\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\nstore<span class="token punctuation">.</span><span class="token method function property-access">commit</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>\n</code></pre>\n<p>在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// ...</span>\nmutations<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">+=</span> payload<span class="token punctuation">.</span><span class="token property-access">amount</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\nstore<span class="token punctuation">.</span><span class="token method function property-access">commit</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  amount<span class="token operator">:</span> <span class="token number">10</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h2 id="%E5%AF%B9%E8%B1%A1%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F">对象风格的提交方式<a class="anchor" href="#%E5%AF%B9%E8%B1%A1%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F">§</a></h2>\n<p>提交 <code>mutation</code> 的另一种方式是直接使用包含 <code>type</code> 属性的对象：</p>\n<pre class="language-js"><code class="language-js">store<span class="token punctuation">.</span><span class="token method function property-access">commit</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  type<span class="token operator">:</span> <span class="token string">\'increment\'</span><span class="token punctuation">,</span>\n  amount<span class="token operator">:</span> <span class="token number">10</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>当使用对象风格的提交方式，整个对象都作为载荷传给 <code>mutation</code> 函数，因此 <code>handler</code> 保持不变：</p>\n<pre class="language-js"><code class="language-js">mutations<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">+=</span> payload<span class="token punctuation">.</span><span class="token property-access">amount</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h2 id="mutation-%E9%9C%80%E9%81%B5%E5%AE%88-vue-%E7%9A%84%E5%93%8D%E5%BA%94%E8%A7%84%E5%88%99">Mutation 需遵守 Vue 的响应规则<a class="anchor" href="#mutation-%E9%9C%80%E9%81%B5%E5%AE%88-vue-%E7%9A%84%E5%93%8D%E5%BA%94%E8%A7%84%E5%88%99">§</a></h2>\n<p>既然 <code>Vuex</code> 的 <code>store</code> 中的状态是响应式的，那么当我们变更状态时，监视状态的 <code>Vue</code> 组件也会自动更新。这也意味着 <code>Vuex</code> 中的 <code>mutation</code> 也需要与使用 <code>Vue</code> 一样遵守一些注意事项：</p>\n<ol>\n<li>\n<p>最好提前在你的 <code>store</code> 中初始化好所有所需属性。</p>\n</li>\n<li>\n<p>当需要在对象上添加新属性时，你应该:</p>\n<ol>\n<li>使用 <code>Vue.set(obj, \'newProp\', 123)</code>, 或者</li>\n<li>以新对象替换老对象。例如，利用对象展开运算符,我们可以这样写：</li>\n</ol>\n<pre class="language-js"><code class="language-js">state<span class="token punctuation">.</span><span class="token property-access">obj</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span>state<span class="token punctuation">.</span><span class="token property-access">obj</span><span class="token punctuation">,</span> newProp<span class="token operator">:</span> <span class="token number">123</span> <span class="token punctuation">}</span>\n</code></pre>\n</li>\n</ol>\n<h2 id="%E4%BD%BF%E7%94%A8%E5%B8%B8%E9%87%8F%E6%9B%BF%E4%BB%A3-mutation-%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B">使用常量替代 Mutation 事件类型<a class="anchor" href="#%E4%BD%BF%E7%94%A8%E5%B8%B8%E9%87%8F%E6%9B%BF%E4%BB%A3-mutation-%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B">§</a></h2>\n<p>使用常量替代 <code>mutation</code> 事件类型在各种 <code>Flux</code> 实现中是很常见的模式。这样可以使 <code>linter</code> 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 <code>app</code> 包含的 <code>mutation</code> 一目了然：</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// mutation-types.js</span>\n<span class="token keyword module">export</span> <span class="token keyword">const</span> <span class="token constant">SOME_MUTATION</span> <span class="token operator">=</span> <span class="token string">\'SOME_MUTATION\'</span>\n\n<span class="token comment">// store.js</span>\n<span class="token comment">// store.js</span>\n<span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">Vuex</span></span> <span class="token keyword module">from</span> <span class="token string">\'vuex\'</span>\n<span class="token keyword module">import</span> <span class="token punctuation">{</span> <span class="token constant">SOME_MUTATION</span> <span class="token punctuation">}</span> <span class="token keyword module">from</span> <span class="token string">\'./mutation-types\'</span>\n\n<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  state<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  mutations<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span>\n    <span class="token punctuation">[</span><span class="token constant">SOME_MUTATION</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// mutate state</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做</p>\n<h2 id="mutation-%E5%BF%85%E9%A1%BB%E6%98%AF%E5%90%8C%E6%AD%A5%E5%87%BD%E6%95%B0">Mutation 必须是同步函数<a class="anchor" href="#mutation-%E5%BF%85%E9%A1%BB%E6%98%AF%E5%90%8C%E6%AD%A5%E5%87%BD%E6%95%B0">§</a></h2>\n<p>一条重要的原则就是要记住 mutation 必须是同步函数。为什么？请参考下面的例子：</p>\n<pre class="language-js"><code class="language-js">mutations<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">someMutation</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    api<span class="token punctuation">.</span><span class="token method function property-access">callAsyncMethod</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n      state<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token operator">++</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>现在想象，我们正在 <code>debug</code> 一个 <code>app</code> 并且观察 <code>devtool</code> 中的 <code>mutation</code> 日志。每一条 <code>mutation</code> <code>被记录，devtools</code> 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 <code>mutation</code> 中的异步函数中的回调让这不可能完成：因为当 <code>mutation</code> 触发的时候，回调函数还没有被调用， <code>devtools</code> 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。</p>\n<h2 id="%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%8F%90%E4%BA%A4-mutation">在组件中提交 Mutation<a class="anchor" href="#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%8F%90%E4%BA%A4-mutation">§</a></h2>\n<p>你可以在组件中使用 <code>this.$store.commit(\'xxx\')</code> <code>提交 mutation</code>，或者使用 <code>mapMutations</code> 辅助函数将组件中的 <code>methods</code> 映射为 <code>store.commit</code> 调用（需要在根节点注入 store）。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> mapMutations <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">\'vuex\'</span>\n\n<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  methods<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token spread operator">...</span><span class="token method function property-access">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">[</span>\n      <span class="token string">\'increment\'</span><span class="token punctuation">,</span> <span class="token comment">// 将 `this.increment()` 映射为 `this.$store.commit(\'increment\')`</span>\n\n      <span class="token comment">// `mapMutations` 也支持载荷：</span>\n      <span class="token string">\'incrementBy\'</span> <span class="token comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(\'incrementBy\', amount)`</span>\n    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token spread operator">...</span><span class="token method function property-access">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      add<span class="token operator">:</span> <span class="token string">\'increment\'</span> <span class="token comment">// 将 `this.add()` 映射为 `this.$store.commit(\'increment\')`</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h1>Actions</h1>\n<p><code>Action</code> 类似于 <code>mutation</code>，不同在于：</p>\n<ol>\n<li>Action 提交的是 mutation，而不是直接变更状态。</li>\n<li>Action 可以包含任意异步操作。</li>\n</ol>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  state<span class="token operator">:</span> <span class="token punctuation">{</span>\n    count<span class="token operator">:</span> <span class="token number">0</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  mutations<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      state<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token operator">++</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  actions<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      context<span class="token punctuation">.</span><span class="token method function property-access">commit</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p><code>Action</code> 函数接受一个与 <code>store</code> 实例具有相同方法和属性的 <code>context</code> 对象，因此你可以调用 <code>context.commit</code> 提交一个 <code>mutation</code>，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 <code>state</code> 和 <code>getters</code>。当我们在之后介绍到 <code>Modules</code> 时，你就知道 <code>context</code> 对象为什么不是 <code>store</code> 实例本身了。</p>\n<p>实践中，我们会经常用到 <code>ES2015</code> 的 <code>参数解构</code> 来简化代码（特别是我们需要调用 <code>commit</code> 很多次的时候）：</p>\n<pre class="language-js"><code class="language-js">actions<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> commit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h2 id="%E5%88%86%E5%8F%91-action">分发 Action<a class="anchor" href="#%E5%88%86%E5%8F%91-action">§</a></h2>\n<p><code>Action</code> 通过 <code>store.dispatch</code> 方法触发：</p>\n<pre class="language-js"><code class="language-js">store<span class="token punctuation">.</span><span class="token method function property-access">dispatch</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">)</span>\n</code></pre>\n<p>乍一眼看上去感觉多此一举，我们直接分发 <code>mutation</code> 岂不更方便？实际上并非如此，还记得 <code>mutation</code> 必须同步执行这个限制么？<code>Action</code> 就不受约束！我们可以在 <code>action</code> 内部执行异步操作：</p>\n<pre class="language-js"><code class="language-js">actions<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">incrementAsync</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> commit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n      <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p><code>Actions</code> 支持同样的载荷方式和对象方式进行分发：</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 以载荷形式分发</span>\nstore<span class="token punctuation">.</span><span class="token method function property-access">dispatch</span><span class="token punctuation">(</span><span class="token string">\'incrementAsync\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  amount<span class="token operator">:</span> <span class="token number">10</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 以对象形式分发</span>\nstore<span class="token punctuation">.</span><span class="token method function property-access">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  type<span class="token operator">:</span> <span class="token string">\'incrementAsync\'</span><span class="token punctuation">,</span>\n  amount<span class="token operator">:</span> <span class="token number">10</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>来看一个更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation：</p>\n<pre class="language-js"><code class="language-js">actions<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">checkout</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> commit<span class="token punctuation">,</span> state <span class="token punctuation">}</span><span class="token punctuation">,</span> products</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 备份当前购物车的物品</span>\n        <span class="token keyword">const</span> savedCartItems <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token spread operator">...</span>state<span class="token punctuation">.</span><span class="token property-access">cart</span><span class="token punctuation">.</span><span class="token property-access">added</span><span class="token punctuation">]</span>\n        <span class="token comment">// 发出结账请求，然后清空购物车</span>\n        <span class="token function">commit</span><span class="token punctuation">(</span>types<span class="token punctuation">.</span><span class="token constant">CHECKOUT_REQUEST</span><span class="token punctuation">)</span>\n        <span class="token comment">// 购物API接受一个成功回调和一个失败回调</span>\n        shop<span class="token punctuation">.</span><span class="token method function property-access">buyProducts</span><span class="token punctuation">(</span>products<span class="token punctuation">,</span>\n            <span class="token comment">// 成功操作</span>\n            <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">commit</span><span class="token punctuation">(</span>types<span class="token punctuation">.</span><span class="token constant">CHECKOUT_SUCCESS</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n            <span class="token comment">// 失败操作</span>\n            <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token function">commit</span><span class="token punctuation">(</span>types<span class="token punctuation">.</span><span class="token constant">CHECKOUT_FAILURE</span><span class="token punctuation">,</span> savedCartItems<span class="token punctuation">)</span>\n        <span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>注意我们正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）。</p>\n<h2 id="%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%88%86%E5%8F%91-action">在组件中分发 Action<a class="anchor" href="#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%88%86%E5%8F%91-action">§</a></h2>\n<p>你在组件中使用 <code>this.$store.dispatch(\'xxx\')</code> 分发 action，或者使用 <code>mapActions</code> 辅助函数将组件的 <code>methods</code> 映射为 <code>store.dispatch</code> 调用（需要先在根节点注入 store）：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> mapActions <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">\'vuex\'</span>\n\n<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  methods<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token spread operator">...</span><span class="token method function property-access">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span>\n      <span class="token string">\'increment\'</span><span class="token punctuation">,</span> <span class="token comment">// 将 `this.increment()` 映射为 `this.$store.dispatch(\'increment\')`</span>\n\n      <span class="token comment">// `mapActions` 也支持载荷：</span>\n      <span class="token string">\'incrementBy\'</span> <span class="token comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(\'incrementBy\', amount)`</span>\n    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token spread operator">...</span><span class="token method function property-access">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      add<span class="token operator">:</span> <span class="token string">\'increment\'</span> <span class="token comment">// 将 `this.add()` 映射为 `this.$store.dispatch(\'increment\')`</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h2 id="%E7%BB%84%E5%90%88-action">组合 Action<a class="anchor" href="#%E7%BB%84%E5%90%88-action">§</a></h2>\n<p><code>Action</code> 通常是异步的，那么如何知道 <code>action</code> 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p>\n<p>首先，你需要明白 <code>store.dispatch</code> 可以处理被触发的 <code>action</code> 的处理函数返回的 <code>Promise</code>，并且 <code>store.dispatch</code> 仍旧返回 <code>Promise</code>：</p>\n<pre class="language-js"><code class="language-js">actions<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function">actionA</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> commit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n        <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'someMutation\'</span><span class="token punctuation">)</span>\n        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>现在你可以：</p>\n<pre class="language-js"><code class="language-js">store<span class="token punctuation">.</span><span class="token method function property-access">dispatch</span><span class="token punctuation">(</span><span class="token string">\'actionA\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>在另外一个 action 中也可以：</p>\n<pre class="language-js"><code class="language-js">actions<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  <span class="token function">actionB</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> dispatch<span class="token punctuation">,</span> commit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">return</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">\'actionA\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n      <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'someOtherMutation\'</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>最后，如果我们利用 <code>async / await</code> ，我们可以如下组合 action：</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span>\n\nactions<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token keyword">async</span> <span class="token function">actionA</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> commit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'gotData\'</span><span class="token punctuation">,</span> <span class="token keyword control-flow">await</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token keyword">async</span> <span class="token function">actionB</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> dispatch<span class="token punctuation">,</span> commit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">await</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">\'actionA\'</span><span class="token punctuation">)</span> <span class="token comment">// 等待 actionA 完成</span>\n    <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'gotOtherData\'</span><span class="token punctuation">,</span> <span class="token keyword control-flow">await</span> <span class="token function">getOtherData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>一个 <code>store.dispatch </code>在不同模块中可以触发多个 <code>action</code> 函数。在这种情况下，只有当所有触发函数完成后，返回的 <code>Promise</code> 才会执行。</p>\n<h1>Module</h1>\n<p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p>\n<p>为了解决以上问题，Vuex 允许我们将 store 分割成<code>模块（module）</code>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">state</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  mutations<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  actions<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  getters<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> moduleB <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">state</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  mutations<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  actions<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  modules<span class="token operator">:</span> <span class="token punctuation">{</span>\n    a<span class="token operator">:</span> moduleA<span class="token punctuation">,</span>\n    b<span class="token operator">:</span> moduleB\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\nstore<span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">a</span> <span class="token comment">// -> moduleA 的状态</span>\nstore<span class="token punctuation">.</span><span class="token property-access">state</span><span class="token punctuation">.</span><span class="token property-access">b</span> <span class="token comment">// -> moduleB 的状态</span>\n</code></pre>\n<h2 id="%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B1%80%E9%83%A8%E7%8A%B6%E6%80%81">模块的局部状态<a class="anchor" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B1%80%E9%83%A8%E7%8A%B6%E6%80%81">§</a></h2>\n<p>对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">state</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>\n    count<span class="token operator">:</span> <span class="token number">0</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  mutations<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 这里的 `state` 对象是模块的局部状态</span>\n      state<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token operator">++</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n  getters<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">doubleCount</span> <span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword control-flow">return</span> state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">*</span> <span class="token number">2</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>同样，对于模块内部的 action，局部状态通过 <code>context.state</code> 暴露出来，根节点状态则为 <code>context.rootState</code>：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  actions<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">incrementIfOddOnRootSum</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> state<span class="token punctuation">,</span> commit<span class="token punctuation">,</span> rootState <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">+</span> rootState<span class="token punctuation">.</span><span class="token property-access">count</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">)</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  getters<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">sumWithRootCount</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> getters<span class="token punctuation">,</span> rootState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword control-flow">return</span> state<span class="token punctuation">.</span><span class="token property-access">count</span> <span class="token operator">+</span> rootState<span class="token punctuation">.</span><span class="token property-access">count</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h2 id="%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">命名空间<a class="anchor" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">§</a></h2>\n<p>默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。</p>\n<p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  modules<span class="token operator">:</span> <span class="token punctuation">{</span>\n    account<span class="token operator">:</span> <span class="token punctuation">{</span>\n      namespaced<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n\n      <span class="token comment">// 模块内容（module assets）</span>\n      <span class="token function-variable function">state</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span>\n      getters<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token function">isAdmin</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span> <span class="token comment">// -> getters[\'account/isAdmin\']</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span>\n      actions<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token function">login</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span> <span class="token comment">// -> dispatch(\'account/login\')</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span>\n      mutations<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token function">login</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span> <span class="token comment">// -> commit(\'account/login\')</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n      <span class="token comment">// 嵌套模块</span>\n      modules<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 继承父模块的命名空间</span>\n        myPage<span class="token operator">:</span> <span class="token punctuation">{</span>\n          <span class="token function-variable function">state</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n          getters<span class="token operator">:</span> <span class="token punctuation">{</span>\n            <span class="token function">profile</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span> <span class="token comment">// -> getters[\'account/profile\']</span>\n          <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n        <span class="token comment">// 进一步嵌套命名空间</span>\n        posts<span class="token operator">:</span> <span class="token punctuation">{</span>\n          namespaced<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n\n          <span class="token function-variable function">state</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n          getters<span class="token operator">:</span> <span class="token punctuation">{</span>\n            <span class="token function">popular</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span> <span class="token comment">// -> getters[\'account/posts/popular\']</span>\n          <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>启用了命名空间的 getter 和 action 会收到局部化的 getter，dispatch 和 commit。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 namespaced 属性后不需要修改模块内的代码</p>\n<h2 id="%E5%9C%A8%E5%B8%A6%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%86%8C%E5%85%A8%E5%B1%80-action">在带命名空间的模块注册全局 action<a class="anchor" href="#%E5%9C%A8%E5%B8%A6%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%86%8C%E5%85%A8%E5%B1%80-action">§</a></h2>\n<p>若需要在带命名空间的模块注册全局 action，你可添加 root: true，并将这个 action 的定义放在函数 handler 中。例如：</p>\n<pre class="language-js"><code class="language-js"><span class="token punctuation">{</span>\n  actions<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token function">someOtherAction</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>dispatch<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">\'someAction\'</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  modules<span class="token operator">:</span> <span class="token punctuation">{</span>\n    foo<span class="token operator">:</span> <span class="token punctuation">{</span>\n      namespaced<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n\n      actions<span class="token operator">:</span> <span class="token punctuation">{</span>\n        someAction<span class="token operator">:</span> <span class="token punctuation">{</span>\n          root<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n          <span class="token function">handler</span> <span class="token punctuation">(</span><span class="token parameter">namespacedContext<span class="token punctuation">,</span> payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span> <span class="token comment">// -> \'someAction\'</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h2 id="%E5%B8%A6%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E7%BB%91%E5%AE%9A%E5%87%BD%E6%95%B0">带命名空间的绑定函数<a class="anchor" href="#%E5%B8%A6%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E7%BB%91%E5%AE%9A%E5%87%BD%E6%95%B0">§</a></h2>\n<p>当使用 mapState, mapGetters, mapActions 和 mapMutations 这些函数来绑定带命名空间的模块时，写起来可能比较繁琐：</p>\n<pre class="language-js"><code class="language-js">computed<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token spread operator">...</span><span class="token method function property-access">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token arrow operator">=></span> state<span class="token punctuation">.</span><span class="token property-access">some</span><span class="token punctuation">.</span><span class="token property-access">nested</span><span class="token punctuation">.</span><span class="token property-access">module</span><span class="token punctuation">.</span><span class="token property-access">a</span><span class="token punctuation">,</span>\n    <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token arrow operator">=></span> state<span class="token punctuation">.</span><span class="token property-access">some</span><span class="token punctuation">.</span><span class="token property-access">nested</span><span class="token punctuation">.</span><span class="token property-access">module</span><span class="token punctuation">.</span><span class="token property-access">b</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\nmethods<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token spread operator">...</span><span class="token method function property-access">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span>\n    <span class="token string">\'some/nested/module/foo\'</span><span class="token punctuation">,</span> <span class="token comment">// -> this[\'some/nested/module/foo\']()</span>\n    <span class="token string">\'some/nested/module/bar\'</span> <span class="token comment">// -> this[\'some/nested/module/bar\']()</span>\n  <span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>对于这种情况，你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。于是上面的例子可以简化为：</p>\n<pre class="language-js"><code class="language-js">computed<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token spread operator">...</span><span class="token method function property-access">mapState</span><span class="token punctuation">(</span><span class="token string">\'some/nested/module\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n    <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token arrow operator">=></span> state<span class="token punctuation">.</span><span class="token property-access">a</span><span class="token punctuation">,</span>\n    <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token arrow operator">=></span> state<span class="token punctuation">.</span><span class="token property-access">b</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\nmethods<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token spread operator">...</span><span class="token method function property-access">mapActions</span><span class="token punctuation">(</span><span class="token string">\'some/nested/module\'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>\n    <span class="token string">\'foo\'</span><span class="token punctuation">,</span> <span class="token comment">// -> this.foo()</span>\n    <span class="token string">\'bar\'</span> <span class="token comment">// -> this.bar()</span>\n  <span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>而且，你可以通过使用 createNamespacedHelpers 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> createNamespacedHelpers <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">\'vuex\'</span>\n\n<span class="token keyword">const</span> <span class="token punctuation">{</span> mapState<span class="token punctuation">,</span> mapActions <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">createNamespacedHelpers</span><span class="token punctuation">(</span><span class="token string">\'some/nested/module\'</span><span class="token punctuation">)</span>\n\n<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token punctuation">{</span>\n  computed<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 在 `some/nested/module` 中查找</span>\n    <span class="token spread operator">...</span><span class="token method function property-access">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      <span class="token function-variable function">a</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token arrow operator">=></span> state<span class="token punctuation">.</span><span class="token property-access">a</span><span class="token punctuation">,</span>\n      <span class="token function-variable function">b</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token arrow operator">=></span> state<span class="token punctuation">.</span><span class="token property-access">b</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  methods<span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 在 `some/nested/module` 中查找</span>\n    <span class="token spread operator">...</span><span class="token method function property-access">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span>\n      <span class="token string">\'foo\'</span><span class="token punctuation">,</span>\n      <span class="token string">\'bar\'</span>\n    <span class="token punctuation">]</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h2 id="%E6%A8%A1%E5%9D%97%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C">模块动态注册<a class="anchor" href="#%E6%A8%A1%E5%9D%97%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C">§</a></h2>\n<p>在 store 创建之后，你可以使用 store.registerModule 方法注册模块：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword module">import</span> <span class="token imports"><span class="token maybe-class-name">Vuex</span></span> <span class="token keyword module">from</span> <span class="token string">\'vuex\'</span>\n\n<span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token comment">/* 选项 */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 注册模块 `myModule`</span>\nstore<span class="token punctuation">.</span><span class="token method function property-access">registerModule</span><span class="token punctuation">(</span><span class="token string">\'myModule\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token comment">// 注册嵌套模块 `nested/myModule`</span>\nstore<span class="token punctuation">.</span><span class="token method function property-access">registerModule</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">\'nested\'</span><span class="token punctuation">,</span> <span class="token string">\'myModule\'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>之后就可以通过 <code>store.state.myModule</code> 和 <code>store.state.nested.myModule</code> 访问模块的状态。</p>'
        } }),
    'toc': React.createElement("aside", { dangerouslySetInnerHTML: {
            __html: '<nav class="toc"><ol><li><a href="#%E5%8D%95%E4%B8%80%E7%8A%B6%E6%80%81%E6%A0%91">单一状态树</a></li><li><a href="#%E5%9C%A8-vue-%E7%BB%84%E4%BB%B6%E4%B8%AD%E8%8E%B7%E5%BE%97-vuex-%E7%8A%B6%E6%80%81">在 Vue 组件中获得 Vuex 状态</a></li><li><a href="#mapstate-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0">mapState 辅助函数</a></li><li><a href="#%E5%AF%B9%E8%B1%A1%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6">对象展开运算符</a></li><li><a href="#%E9%80%9A%E8%BF%87%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE">通过属性访问</a></li><li><a href="#%E9%80%9A%E8%BF%87%E6%96%B9%E6%B3%95%E8%AE%BF%E9%97%AE">通过方法访问</a></li><li><a href="#mapgetters-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0">mapGetters 辅助函数</a></li><li><a href="#%E6%8F%90%E4%BA%A4%E8%BD%BD%E8%8D%B7payload">提交载荷（Payload）</a></li><li><a href="#%E5%AF%B9%E8%B1%A1%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F">对象风格的提交方式</a></li><li><a href="#mutation-%E9%9C%80%E9%81%B5%E5%AE%88-vue-%E7%9A%84%E5%93%8D%E5%BA%94%E8%A7%84%E5%88%99">Mutation 需遵守 Vue 的响应规则</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E5%B8%B8%E9%87%8F%E6%9B%BF%E4%BB%A3-mutation-%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B">使用常量替代 Mutation 事件类型</a></li><li><a href="#mutation-%E5%BF%85%E9%A1%BB%E6%98%AF%E5%90%8C%E6%AD%A5%E5%87%BD%E6%95%B0">Mutation 必须是同步函数</a></li><li><a href="#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%8F%90%E4%BA%A4-mutation">在组件中提交 Mutation</a></li><li><a href="#%E5%88%86%E5%8F%91-action">分发 Action</a></li><li><a href="#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%88%86%E5%8F%91-action">在组件中分发 Action</a></li><li><a href="#%E7%BB%84%E5%90%88-action">组合 Action</a></li><li><a href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B1%80%E9%83%A8%E7%8A%B6%E6%80%81">模块的局部状态</a></li><li><a href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">命名空间</a></li><li><a href="#%E5%9C%A8%E5%B8%A6%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%86%8C%E5%85%A8%E5%B1%80-action">在带命名空间的模块注册全局 action</a></li><li><a href="#%E5%B8%A6%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E7%BB%91%E5%AE%9A%E5%87%BD%E6%95%B0">带命名空间的绑定函数</a></li><li><a href="#%E6%A8%A1%E5%9D%97%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C">模块动态注册</a></li></ol></nav>'
        } }),
    'author': "jianyun2020",
    'contributors': [
        "jianyun2020"
    ],
    'date': "2021-03-15T02:10:17.000Z",
    'updated': "2021-03-17T08:00:55.000Z",
    'excerpt': "Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容...",
    'cover': undefined,
    'categories': [
        "Vue"
    ],
    'tags': [
        "Vuex",
        "学习笔记"
    ],
    'blog': {
        "isPost": true,
        "posts": [
            {
                "pagePath": "posts/Vue Router.md",
                "title": "Vue Router",
                "link": "posts/Vue Router.html",
                "date": "2021-03-17T08:01:47.000Z",
                "updated": "2021-03-19T05:30:51.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "Vue"
                ],
                "tags": [
                    "Vue Router",
                    "学习笔记"
                ],
                "excerpt": "基础 起步 用 Vue.js + Vue Router 创建单页应用，感觉很自然：使用 Vue.js ，我们已经可以通过组合组件来组成应用程序，当你要把 Vue Router 添加进来，我们需要做的是，将组件 (components) 映射到路由 (routes)，然后告诉 V..."
            },
            {
                "pagePath": "posts/Vuex.md",
                "title": "Vuex",
                "link": "posts/Vuex.html",
                "date": "2021-03-15T02:10:17.000Z",
                "updated": "2021-03-17T08:00:55.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "Vue"
                ],
                "tags": [
                    "Vuex",
                    "学习笔记"
                ],
                "excerpt": "Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容..."
            },
            {
                "pagePath": "posts/跨浏览器标签页通信.md",
                "title": "跨浏览器标签页通信",
                "link": "posts/跨浏览器标签页通信.html",
                "date": "2021-03-11T04:59:20.000Z",
                "updated": null,
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "HTML"
                ],
                "tags": [
                    "面试",
                    "跨页面通信",
                    "学习笔记"
                ],
                "excerpt": "在浏览器中，我们可以同时打开多个Tab页，每个Tab页可以粗略理解为一个“独立”的运行环境，即使是全局对象也不会在多个Tab间共享。然而有些时候，我们希望能在这些“独立”的Tab页面之间同步页面的数据、信息或状态。 正如下面...",
                "cover": "../posts/images/html.gif"
            },
            {
                "pagePath": "posts/history和hash两种路由.md",
                "title": "history和hash两种路由",
                "link": "posts/history和hash两种路由.html",
                "date": "2021-03-11T04:59:20.000Z",
                "updated": "2021-03-11T05:40:11.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "HTML"
                ],
                "tags": [
                    "面试",
                    "路由",
                    "学习笔记"
                ],
                "excerpt": "什么是SPA SPA 是 single page web application 的简称，译为单页Web应用。 简单的说 SPA 就是一个WEB项目只有一个 HTML 页面，一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转。 取而代之的是利用 JS 动...",
                "cover": "images/chuantong.png"
            },
            {
                "pagePath": "posts/动态规划.md",
                "title": "动态规划",
                "link": "posts/动态规划.html",
                "date": "2021-03-11T04:59:20.000Z",
                "updated": null,
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "算法"
                ],
                "tags": [
                    "面试",
                    "动态规划",
                    "学习笔记"
                ],
                "excerpt": "动态规划（英语：Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结..."
            },
            {
                "pagePath": "posts/111.md",
                "title": "每日总结",
                "link": "posts/111.html",
                "date": "2021-03-04T13:28:28.000Z",
                "updated": "2021-03-21T13:23:39.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "Vue"
                ],
                "tags": [
                    "面试",
                    "原型链",
                    "学习笔记"
                ],
                "excerpt": "周末时间利用 s 1111"
            },
            {
                "pagePath": "posts/继承.md",
                "title": "继承",
                "link": "posts/继承.html",
                "date": "2021-03-04T13:28:28.000Z",
                "updated": "2021-03-08T13:18:57.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "JavaScript"
                ],
                "tags": [
                    "学习笔记",
                    "继承",
                    "面试"
                ],
                "excerpt": "原型链继承 function Parent() { this.name = 'kevin'; } Parent.prototype.getName = function() { console.log(this.name); } function Child() { } Child.prototype = new Parent(); var child1 = new Child(); console.log..."
            },
            {
                "pagePath": "posts/行内元素和块级元素.md",
                "title": "行内元素和块级元素",
                "link": "posts/行内元素和块级元素.html",
                "date": "2021-03-04T13:28:28.000Z",
                "updated": null,
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "HTML"
                ],
                "tags": [
                    "行内元素和块级元素"
                ],
                "excerpt": "常用行内元素 - a：锚点 - span：常用内联容器，定义文本内区块 - label：表格标签 - strong：粗体强调 - em：强调 - br：换行 - img：图片 - input：输入框 - select：项目选择 - textarea：多行文本输入框 - cite：引用 常用..."
            },
            {
                "pagePath": "posts/微信内置浏览器播放视频.md",
                "title": "微信内置X5内核浏览器播放视频相关问题",
                "link": "posts/微信内置浏览器播放视频.html",
                "date": "2021-03-03T12:50:17.000Z",
                "updated": "2021-03-03T13:18:54.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "微信的坑"
                ],
                "tags": [
                    "视频播放"
                ],
                "excerpt": "官网 原生video标签 <video id=\"vid\" src=\"./assets/test.mp4\" poster=\"./assets/test.png\" controls></video> X5内核视频两种播放形态 1. 页面内播放 X5内核视频在用户点击后默认会进入全屏播放，前端可以设置video的x5-plays...",
                "cover": "images/wx01.png"
            },
            {
                "pagePath": "posts/Golang基础.md",
                "title": "Golang基础",
                "link": "posts/Golang基础.html",
                "date": "2021-02-26T04:55:47.000Z",
                "updated": "2021-02-26T05:36:43.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "Golang"
                ],
                "tags": [
                    "学习笔记"
                ],
                "excerpt": "基本语法 package main import \"fmt\" func main() { // 此括号不能写在单独行 fmt.Println(\"Hello Go~\") } 格式化字符串 Go语言使用fmt.Sprintf格式化字符串并赋值给新串 package main import \"fmt\" func main() { // %d表示整..."
            },
            {
                "pagePath": "posts/原型链.md",
                "title": "原型链",
                "link": "posts/原型链.html",
                "date": "2021-02-25T14:45:38.000Z",
                "updated": "2021-03-04T13:37:41.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "JavaScript"
                ],
                "tags": [
                    "面试",
                    "原型链",
                    "学习笔记"
                ],
                "excerpt": "构造函数 本质就是函数，与普通函数一样，一般命名首字母大写来与普通函数区分，用new关键字调用。 **每个函数再创建时，会自动创建prototype属性，它指向一个对象，这个对象正是调用该构造函数而创建的实例的原型。**每一个Ja..."
            },
            {
                "pagePath": "posts/UE4.md",
                "title": "UE4学习笔记",
                "link": "posts/UE4.html",
                "date": "2021-02-01T04:46:51.000Z",
                "updated": "2021-03-11T09:31:40.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "UE4"
                ],
                "tags": [
                    "UE4",
                    "学习笔记"
                ],
                "excerpt": " 1. 常用快捷键 2. 变更路线节点：Reroute Node 3. Execute Console Command命令 1. 设置分辨率r.setRes 1920x1080 2. r.ScreenPercentage 200：双倍渲染 UE4像素流送系统 特点： 1. 流送并非播放预先录制的视频片段，而是播放...",
                "cover": "images/shortcut_key1.png"
            },
            {
                "pagePath": "posts/React笔记.md",
                "title": "React学习笔记",
                "link": "posts/React笔记.html",
                "date": "2021-01-29T14:58:22.000Z",
                "updated": "2021-02-21T23:30:13.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "React"
                ],
                "tags": [
                    "React",
                    "学习笔记"
                ],
                "excerpt": " 1. 在html中简易使用jsx语法时，需要引入babel插件，同时设置<script type=\"text/babel\"></script> 2. js语法创建虚拟DOM：React.createElement('h1', {id: 'test'}, 'Hello, React') 3. 关于虚拟DOM： 1. 本质就是Object类型...",
                "cover": "images/lifeold.png"
            },
            {
                "pagePath": "posts/前端基础面试题.md",
                "title": "HTML篇",
                "link": "posts/前端基础面试题.html",
                "date": "2021-01-27T07:14:50.000Z",
                "updated": "2021-02-01T04:46:51.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "面试"
                ],
                "tags": [
                    "面试",
                    "HTML",
                    "CSS",
                    "JavaScript"
                ],
                "excerpt": "说说title和alt属性 HTML5有哪些新特性、移除了哪些元素 iframe有那些缺点？ HTML W3C的标准 Doctype作用? 严格模式与混杂模式如何区分？它们有何意义? HTML全局属性(global attribute)有哪些 viewport的content属性作用 div+c..."
            },
            {
                "pagePath": "posts/前端本地存储.md",
                "title": "前端本地存储",
                "link": "posts/前端本地存储.html",
                "date": "2021-01-27T03:51:39.000Z",
                "updated": null,
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "面试"
                ],
                "tags": [
                    "面试",
                    "学习笔记",
                    "前端本地存储"
                ],
                "excerpt": "cookie 作用 cookie是纯文本，没有可执行代码。存储数据，当用户访问了某个网站（网页）的时候，我们就可以通过cookie来向访问者电脑上存储数据，或者某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（..."
            },
            {
                "pagePath": "posts/跨域及常见解决办法.md",
                "title": "跨域及常见解决方法",
                "link": "posts/跨域及常见解决办法.html",
                "date": "2021-01-26T10:06:49.000Z",
                "updated": null,
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "面试"
                ],
                "tags": [
                    "面试",
                    "学习笔记",
                    "跨域"
                ],
                "excerpt": "什么是跨域 跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。 广义的跨域： 1. 资源跳转：A链接、重定向、表单提交 2. 资源嵌入：<link>、<script>、<img>、<frame>等dom标签，还有样式中backgrou..."
            },
            {
                "pagePath": "posts/垃圾回收机制.md",
                "title": "垃圾回收机制",
                "link": "posts/垃圾回收机制.html",
                "date": "2021-01-26T03:09:41.000Z",
                "updated": "2021-01-26T06:08:48.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "面试"
                ],
                "tags": [
                    "面试",
                    "学习笔记",
                    "垃圾回收机制"
                ],
                "excerpt": "JavaScript具有自动垃圾收集机制(GC:GarbageCollection)，也就是说，执行环境会负责管理代码执行过程中使用的内存。开发人员不用再关心内存使用问题，所需内存的分配以及无用内存的回收完全实现了自动管理。 内存生命周期 JS环...",
                "cover": "./images/markandsweep.png"
            },
            {
                "pagePath": "posts/防抖和节流.md",
                "title": "防抖和节流",
                "link": "posts/防抖和节流.html",
                "date": "2021-01-25T10:51:54.000Z",
                "updated": "2021-01-26T03:09:41.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "面试"
                ],
                "tags": [
                    "面试",
                    "防抖和节流",
                    "学习笔记"
                ],
                "excerpt": " - 相同：在不影响客户体验的前提下，将频繁的回调函数，进行次数缩减，避免大量计算导致页的页面卡顿。 - 不同：防抖是将多次执行变为最后一次执行，节流是将多次执行变为在规定时间内只执行一次。 防抖 定义：指触发事件后在..."
            },
            {
                "pagePath": "posts/css_渐变.md",
                "title": "CSS渐变",
                "link": "posts/css_渐变.html",
                "date": "2021-01-25T09:32:57.000Z",
                "updated": null,
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "CSS"
                ],
                "tags": [
                    "CSS",
                    "学习笔记",
                    "渐变"
                ],
                "excerpt": "CSS渐变<image>类型的一种特殊类型<gradient>表示，由两种或多种颜色之间的渐进过渡组成。有三种类型的渐变： - 线性（由linear-gradient()函数创建） - 径向（由radial-gradient()函数创建） - 圆锥（由conic-gradient()函数创...",
                "cover": "./images/deg.png"
            },
            {
                "pagePath": "posts/Hook.md",
                "title": "Hook",
                "link": "posts/Hook.html",
                "date": "2021-01-25T07:07:55.000Z",
                "updated": null,
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "React"
                ],
                "tags": [
                    "JavaScript",
                    "学习笔记",
                    "React"
                ],
                "excerpt": "16.8版本新增特性。可以在不编写class的情况下使用state以及其它的React特性。 import React, { useState } from 'react'; function Example() { // 声明一个新的叫做“count”的state变量 const [count, setCount] = useState..."
            },
            {
                "pagePath": "posts/css_background.md",
                "title": "CSS的background属性详解",
                "link": "posts/css_background.html",
                "date": "2021-01-25T07:07:55.000Z",
                "updated": "2021-01-25T08:30:22.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "CSS"
                ],
                "tags": [
                    "CSS",
                    "学习笔记",
                    "background"
                ],
                "excerpt": "background是一中CSS简写属性，可以在一次声明中定义一个或多个属性：background-clip、background-color、background-image、background-origin、background-position、background-repeat、background-size、background-attac..."
            },
            {
                "pagePath": "posts/List.md",
                "title": "数据结构与算法JavaScript-列表",
                "link": "posts/List.html",
                "date": "2021-01-22T08:08:14.000Z",
                "updated": "2021-01-25T02:27:19.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "数据结构与算法"
                ],
                "tags": [
                    "JavaScript",
                    "数据结构与算法",
                    "学习笔记"
                ],
                "excerpt": "列表的抽象数据类型定义 方法和方法 说明 listSize(属性) 列表的元素个数 pos(属性) 列表的当前位置 length(属性) 返回列表中元素的个数 clear(方法) 清空列表中的所有元素 toString(方法) 返回列表的字符串形式 getElement(方..."
            },
            {
                "pagePath": "posts/元素渲染.md",
                "title": "React-元素渲染",
                "link": "posts/元素渲染.html",
                "date": "2021-01-22T08:08:14.000Z",
                "updated": null,
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "React"
                ],
                "tags": [
                    "JavaScript",
                    "学习笔记",
                    "React"
                ],
                "excerpt": "元素是构成React应用的最小砖块，其描述了你在屏幕上想看到的内容。 const element = <h1>Hello, World</h1>; 与浏览器的 DOM 元素不同，React 元素是创建开销极小的普通对象。React DOM 会负责更新 DOM 来与 React 元素保持一..."
            },
            {
                "pagePath": "posts/JSX简介.md",
                "title": "React-JSX简介",
                "link": "posts/JSX简介.html",
                "date": "2021-01-21T07:25:11.000Z",
                "updated": null,
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "React"
                ],
                "tags": [
                    "JavaScript",
                    "学习笔记",
                    "React"
                ],
                "excerpt": "考虑如下变量声明： const element = <h1>Hello, world!</h1>; 这个有趣的标签语法既不是字符串也不是 HTML。它被称为 JSX，是一个 JavaScript 的语法扩展。 在JSX中嵌入表达式 const name = 'Bob'; const element = <h1>Hello..."
            },
            {
                "pagePath": "posts/Array.md",
                "title": "数据结构与算法JavaScript-数组",
                "link": "posts/Array.html",
                "date": "2021-01-20T05:13:02.000Z",
                "updated": "2021-01-21T06:40:51.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "数据结构与算法"
                ],
                "tags": [
                    "JavaScript",
                    "数据结构与算法",
                    "学习笔记"
                ],
                "excerpt": "数组 JavaScript 中的数组是一种特殊的对象， 用来表示偏移量的索引是该对象的属性， 索引可 能是整数。 然而， 这些数字索引在内部被转换为字符串类型， 这是因为 JavaScript 对象中 的属性名必须是字符串。 数组在 JavaScrip..."
            }
        ],
        "categories": [
            {
                "name": "面试",
                "count": 5
            },
            {
                "name": "React",
                "count": 4
            },
            {
                "name": "HTML",
                "count": 3
            },
            {
                "name": "Vue",
                "count": 3
            },
            {
                "name": "CSS",
                "count": 2
            },
            {
                "name": "JavaScript",
                "count": 2
            },
            {
                "name": "数据结构与算法",
                "count": 2
            },
            {
                "name": "Golang",
                "count": 1
            },
            {
                "name": "UE4",
                "count": 1
            },
            {
                "name": "微信的坑",
                "count": 1
            },
            {
                "name": "算法",
                "count": 1
            }
        ],
        "tags": [
            {
                "name": "学习笔记",
                "count": 22
            },
            {
                "name": "面试",
                "count": 11
            },
            {
                "name": "JavaScript",
                "count": 6
            },
            {
                "name": "React",
                "count": 4
            },
            {
                "name": "CSS",
                "count": 3
            },
            {
                "name": "原型链",
                "count": 2
            },
            {
                "name": "数据结构与算法",
                "count": 2
            },
            {
                "name": "background",
                "count": 1
            },
            {
                "name": "HTML",
                "count": 1
            },
            {
                "name": "UE4",
                "count": 1
            },
            {
                "name": "Vue Router",
                "count": 1
            },
            {
                "name": "Vuex",
                "count": 1
            },
            {
                "name": "前端本地存储",
                "count": 1
            },
            {
                "name": "动态规划",
                "count": 1
            },
            {
                "name": "垃圾回收机制",
                "count": 1
            },
            {
                "name": "渐变",
                "count": 1
            },
            {
                "name": "继承",
                "count": 1
            },
            {
                "name": "行内元素和块级元素",
                "count": 1
            },
            {
                "name": "视频播放",
                "count": 1
            },
            {
                "name": "跨域",
                "count": 1
            },
            {
                "name": "跨页面通信",
                "count": 1
            },
            {
                "name": "路由",
                "count": 1
            },
            {
                "name": "防抖和节流",
                "count": 1
            }
        ]
    }
};
