import projectConfig from '/pagic.config.js';
export default {
    config: { "root": "/", ...projectConfig, branch: 'main' },
    'pagePath': "posts/Vue Router.md",
    'layoutPath': "posts/_layout.tsx",
    'outputPath': "posts/Vue Router.html",
    'title': "Vue Router",
    'content': React.createElement("article", { dangerouslySetInnerHTML: {
            __html: '<h1>Vue Router</h1>\n<h2 id="%E5%9F%BA%E7%A1%80">基础<a class="anchor" href="#%E5%9F%BA%E7%A1%80">§</a></h2>\n<h3 id="%E8%B5%B7%E6%AD%A5">起步<a class="anchor" href="#%E8%B5%B7%E6%AD%A5">§</a></h3>\n<p>用 Vue.js + Vue Router 创建单页应用，感觉很自然：使用 Vue.js ，我们已经可以通过组合组件来组成应用程序，当你要把 Vue Router 添加进来，我们需要做的是，将组件 (components) 映射到路由 (routes)，然后告诉 Vue Router 在哪里渲染它们。下面是个基本例子：</p>\n<h4 id="html">HTML<a class="anchor" href="#html">§</a></h4>\n<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><a class="token url-link" href="https://unpkg.com/vue/dist/vue.js">https://unpkg.com/vue/dist/vue.js</a><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><a class="token url-link" href="https://unpkg.com/vue-router/dist/vue-router.js">https://unpkg.com/vue-router/dist/vue-router.js</a><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Hello App!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>\n    <span class="token comment">&lt;!-- 使用 router-link 组件来导航. --></span>\n    <span class="token comment">&lt;!-- 通过传入 `to` 属性指定链接. --></span>\n    <span class="token comment">&lt;!-- &lt;router-link> 默认会被渲染成一个 `&lt;a>` 标签 --></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/foo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Go to Foo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/bar<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Go to Bar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n  <span class="token comment">&lt;!-- 路由出口 --></span>\n  <span class="token comment">&lt;!-- 路由匹配到的组件将渲染在这里 --></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre>\n<h4 id="javascript">JavaScript<a class="anchor" href="#javascript">§</a></h4>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)</span>\n\n<span class="token comment">// 1. 定义 (路由) 组件。</span>\n<span class="token comment">// 可以从其他文件 import 进来</span>\n<span class="token keyword">const</span> <span class="token maybe-class-name">Foo</span> <span class="token operator">=</span> <span class="token punctuation">{</span> template<span class="token operator">:</span> <span class="token string">\'&lt;div>foo&lt;/div>\'</span> <span class="token punctuation">}</span>\n<span class="token keyword">const</span> <span class="token maybe-class-name">Bar</span> <span class="token operator">=</span> <span class="token punctuation">{</span> template<span class="token operator">:</span> <span class="token string">\'&lt;div>bar&lt;/div>\'</span> <span class="token punctuation">}</span>\n\n<span class="token comment">// 2. 定义路由</span>\n<span class="token comment">// 每个路由应该映射一个组件。 其中"component" 可以是</span>\n<span class="token comment">// 通过 Vue.extend() 创建的组件构造器，</span>\n<span class="token comment">// 或者，只是一个组件配置对象。</span>\n<span class="token comment">// 我们晚点再讨论嵌套路由。</span>\n<span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>\n  <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">\'/foo\'</span><span class="token punctuation">,</span> component<span class="token operator">:</span> <span class="token maybe-class-name">Foo</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">\'/bar\'</span><span class="token punctuation">,</span> component<span class="token operator">:</span> <span class="token maybe-class-name">Bar</span> <span class="token punctuation">}</span>\n<span class="token punctuation">]</span>\n\n<span class="token comment">// 3. 创建 router 实例，然后传 `routes` 配置</span>\n<span class="token comment">// 你还可以传别的配置参数, 不过先这么简单着吧。</span>\n<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  routes <span class="token comment">// (缩写) 相当于 routes: routes</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 4. 创建和挂载根实例。</span>\n<span class="token comment">// 记得要通过 router 配置参数注入路由，</span>\n<span class="token comment">// 从而让整个应用都有路由功能</span>\n<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  router\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">$mount</span><span class="token punctuation">(</span><span class="token string">\'#app\'</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 现在，应用已经启动了！</span>\n</code></pre>\n<p>通过注入路由器，我们可以在任何组件内通过 <code>this.$router</code> 访问路由器，也可以通过 <code>this.$route</code> 访问当前路由：</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// Home.vue</span>\n<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token punctuation">{</span>\n    computed<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token function">username</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 我们很快就会看到 `params` 是什么</span>\n            <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$route</span><span class="token punctuation">.</span><span class="token property-access">params</span><span class="token punctuation">.</span><span class="token property-access">username</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    methods<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token function">goBack</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token dom variable">window</span><span class="token punctuation">.</span><span class="token property-access">history</span><span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$router</span><span class="token punctuation">.</span><span class="token method function property-access">go</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$router</span><span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token string">\'/\'</span><span class="token punctuation">)</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>要注意，当 <code>&lt;router-link&gt;</code> 对应的路由匹配成功，将自动设置 <code>class</code> 属性值 <code>.router-link-active</code>。</p>\n<h3 id="%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D">动态路由匹配<a class="anchor" href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D">§</a></h3>\n<p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 <code>User</code> 组件，对于所有 <code>ID</code> 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 <code>vue-router</code> 的路由路径中使用<code>“动态路径参数”(dynamic segment)</code> 来达到这个效果：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">User</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n    template<span class="token operator">:</span> <span class="token string">\'&lt;div>User&lt;/div>\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token comment">// 动态路径参数 以冒号开头</span>\n        <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">\'/user/:id\'</span><span class="token punctuation">,</span> component<span class="token operator">:</span> <span class="token maybe-class-name">User</span> <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>现在呢，像 <code>/user/foo</code> 和 <code>/user/bar</code> 都将映射到相同的路由。</p>\n<p>一个“路径参数”使用冒号<code>:</code>标记。当匹配到一个路由时，参数值会被设置到 <code>this.$route.params</code>，可以在每个组件内使用。于是，我们可以更新 <code>User</code> 的模板，输出当前用户的 <code>ID：</code></p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">User</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n    template<span class="token operator">:</span> <span class="token string">\'&lt;div>{{ this.$route.params.id }}&lt;/div>\'</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>你可以在一个路由中设置多段“路径参数”，对应的值都会设置到<code>$route.params</code>中。例如：</p>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>模式</th>\n<th>匹配路径</th>\n<th>$route.params</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/user/:username</td>\n<td>/user/evan</td>\n<td>{ username: \'evan\'</td>\n</tr>\n<tr>\n<td>/user/:username/post/:post_id</td>\n<td>/user/evan/post/123</td>\n<td>{ username: \'evan\', post_id: \'123\' }</td>\n</tr>\n</tbody>\n</table></div>\n<p>除了<code>$route.params</code> 外，<code>$route</code> 对象还提供了其它有用的信息，例如，<code>$route.query</code> (如果 URL 中有查询参数)、<code>$route.hash</code> 等等。</p>\n<h4 id="%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96">响应路由参数的变化<a class="anchor" href="#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96">§</a></h4>\n<p>提醒一下，当使用路由参数时，例如从 <code>/user/foo</code> 导航到 <code>/user/bar</code>，<strong>原来的组件实例会被复用</strong>。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。<strong>不过，这也意味着组件的生命周期钩子不会再被调用。</strong></p>\n<p>复用组件时，想对路由参数的变化作出响应的话，你可以简单地 <code>watch</code> (监测变化) <code>$route</code> 对象：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">User</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n    template<span class="token operator">:</span> <span class="token string">\'...\'</span><span class="token punctuation">,</span>\n    watch<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token function">$route</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 对路由变化作出响应...</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>或者使用 2.2 中引入的 <code>beforeRouteUpdate</code> 导航守卫：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">User</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n    template<span class="token operator">:</span> <span class="token string">\'...\'</span><span class="token punctuation">,</span>\n    <span class="token function">beforeRouteUpdate</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// react to route changes...</span>\n        <span class="token comment">// don\'t forget to call next()</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h4 id="%E6%8D%95%E8%8E%B7%E6%89%80%E6%9C%89%E8%B7%AF%E7%94%B1%E6%88%96-404-not-found-%E8%B7%AF%E7%94%B1">捕获所有路由或 404 Not found 路由<a class="anchor" href="#%E6%8D%95%E8%8E%B7%E6%89%80%E6%9C%89%E8%B7%AF%E7%94%B1%E6%88%96-404-not-found-%E8%B7%AF%E7%94%B1">§</a></h4>\n<p>常规参数只会匹配被<code>/</code>分隔的 <code>URL</code> 片段中的字符。如果想匹配<strong>任意路径</strong>，我们可以使用<code>通配符 (*)</code>：</p>\n<pre class="language-js"><code class="language-js"><span class="token punctuation">{</span>\n    <span class="token comment">// 匹配所有路径</span>\n    path<span class="token operator">:</span> <span class="token string">\'*\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token punctuation">{</span>\n    <span class="token comment">// 匹配以\'/user-\'开头的任意路径</span>\n    path<span class="token operator">:</span> <span class="token string">\'/user-*\'</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>当使用通配符路由时，请确保路由的顺序是正确的，也就是说含有通配符的路由应该放在最后。路由 <code>{ path: \'*\' } </code>通常用于客户端 404 错误。如果你使用了History 模式，请确保正确配置你的服务器。</p>\n<p>当使用一个通配符时，<code>$route.params</code> 内会自动添加一个名为 <code>pathMatch</code> 参数。它包含了 <code>URL</code> 通过通配符被匹配的部分：</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 给出一个路由 { path: \'/user-*\' }</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$router</span><span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token string">\'/user-admin\'</span><span class="token punctuation">)</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$route</span><span class="token punctuation">.</span><span class="token property-access">params</span><span class="token punctuation">.</span><span class="token property-access">pathMatch</span> <span class="token comment">// \'admin\'</span>\n<span class="token comment">// 给出一个路由 { path: \'*\' }</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$router</span><span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token string">\'/non-existing\'</span><span class="token punctuation">)</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$route</span><span class="token punctuation">.</span><span class="token property-access">params</span><span class="token punctuation">.</span><span class="token property-access">pathMatch</span> <span class="token comment">// \'/non-existing\'</span>\n</code></pre>\n<h4 id="%E5%8C%B9%E9%85%8D%E4%BC%98%E5%85%88%E7%BA%A7">匹配优先级<a class="anchor" href="#%E5%8C%B9%E9%85%8D%E4%BC%98%E5%85%88%E7%BA%A7">§</a></h4>\n<p>有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。</p>\n<h3 id="%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1">嵌套路由<a class="anchor" href="#%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1">§</a></h3>\n<p>实际生活中的应用界面，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层组件，例如：</p>\n<pre class="language-js"><code class="language-js"><span class="token operator">/</span>user<span class="token operator">/</span>foo<span class="token operator">/</span>profile                     <span class="token operator">/</span>user<span class="token operator">/</span>foo<span class="token operator">/</span>posts\n<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>                  <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>\n<span class="token operator">|</span> <span class="token maybe-class-name">User</span>             <span class="token operator">|</span>                  <span class="token operator">|</span> <span class="token maybe-class-name">User</span>            <span class="token operator">|</span>\n<span class="token operator">|</span> <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span> <span class="token operator">|</span>                  <span class="token operator">|</span> <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span> <span class="token operator">|</span>\n<span class="token operator">|</span> <span class="token operator">|</span> <span class="token maybe-class-name">Profile</span>      <span class="token operator">|</span> <span class="token operator">|</span>  <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">></span>  <span class="token operator">|</span> <span class="token operator">|</span> <span class="token maybe-class-name">Posts</span>       <span class="token operator">|</span> <span class="token operator">|</span>\n<span class="token operator">|</span> <span class="token operator">|</span>              <span class="token operator">|</span> <span class="token operator">|</span>                  <span class="token operator">|</span> <span class="token operator">|</span>             <span class="token operator">|</span> <span class="token operator">|</span>\n<span class="token operator">|</span> <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span> <span class="token operator">|</span>                  <span class="token operator">|</span> <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span> <span class="token operator">|</span>\n<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>                  <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>\n</code></pre>\n<p>借助 vue-router，使用嵌套路由配置，就可以很简单地表达这种关系。</p>\n<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">User</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n  template<span class="token operator">:</span> <span class="token string">\'&lt;div>User {{ $route.params.id }}&lt;/div>\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">\'/user/:id\'</span><span class="token punctuation">,</span> component<span class="token operator">:</span> <span class="token maybe-class-name">User</span> <span class="token punctuation">}</span>\n  <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>这里的<code>&lt;router-view&gt;</code>是最顶层的出口，渲染最高级路由匹配到的组件。同样地，一个被渲染组件同样可以包含自己的嵌套 <code>&lt;router-view&gt;</code>。例如，在 User 组件的模板添加一个 <code>&lt;router-view&gt;</code>：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">User</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n    template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">\n        &lt;div class="user">\n            &lt;h2>User {{ $route.params.id }}&lt;/h2>\n            &lt;router-view>&lt;/router-view>\n        &lt;/div>\n    </span><span class="token template-punctuation string">`</span></span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>要在嵌套的出口中渲染组件，需要在 <code>VueRouter</code> 的参数中使用 <code>children</code> 配置：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRotuer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n            path<span class="token operator">:</span> <span class="token string">\'/user/:id\'</span><span class="token punctuation">,</span>\n            component<span class="token operator">:</span> <span class="token maybe-class-name">User</span><span class="token punctuation">,</span>\n            children<span class="token operator">:</span> <span class="token punctuation">[</span>\n                <span class="token punctuation">{</span>\n                    <span class="token comment">// 当/user/:id/profile匹配成功,</span>\n                    <span class="token comment">// UserProfile会被渲染在User的&lt;router-view>中</span>\n                    path<span class="token operator">:</span> <span class="token string">\'profile\'</span><span class="token punctuation">,</span>\n                    component<span class="token operator">:</span> <span class="token maybe-class-name">UserProfile</span>\n                <span class="token punctuation">}</span><span class="token punctuation">,</span>\n                <span class="token punctuation">{</span>\n                    <span class="token comment">// 当/user/:id/posts匹配成功</span>\n                    <span class="token comment">// UserPosts会被渲染在User的&lt;router-view>中</span>\n                    path<span class="token operator">:</span> <span class="token string">\'posts\'</span><span class="token punctuation">,</span>\n                    component<span class="token operator">:</span> <span class="token maybe-class-name">UserPosts</span>\n                <span class="token punctuation">}</span>\n            <span class="token punctuation">]</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>要注意，以<code>/</code> 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。</p>\n<p>你会发现，<code>children</code> 配置就是像 <code>routes</code> 配置一样的路由配置数组，所以呢，你可以嵌套多层路由。</p>\n<p>此时，基于上面的配置，当你访问 <code>/user/foo</code> 时，<code>User</code> 的出口是不会渲染任何东西，这是因为没有匹配到合适的子路由。如果你想要渲染点什么，可以提供一个 <code>空的</code> 子路由：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n            path<span class="token operator">:</span> <span class="token string">\'/user/:id\'</span><span class="token punctuation">,</span>\n            component<span class="token operator">:</span> <span class="token maybe-class-name">User</span><span class="token punctuation">,</span>\n            children<span class="token operator">:</span> <span class="token punctuation">[</span>\n            <span class="token comment">// 当 /user/:id 匹配成功，</span>\n            <span class="token comment">// UserHome 会被渲染在 User 的 &lt;router-view> 中</span>\n            <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">\'\'</span><span class="token punctuation">,</span> component<span class="token operator">:</span> <span class="token maybe-class-name">UserHome</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n            <span class="token comment">// ...其他子路由</span>\n            <span class="token punctuation">]</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h3 id="%E7%BC%96%E7%A8%8B%E5%BC%8F%E7%9A%84%E5%AF%BC%E8%88%AA">编程式的导航<a class="anchor" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E7%9A%84%E5%AF%BC%E8%88%AA">§</a></h3>\n<p>除了使用 <code>&lt;router-link&gt;</code> 创建 <code>a</code> 标签来定义导航链接，我们还可以借助 <code>router</code> 的实例方法，通过编写代码来实现。</p>\n<h4 id="routerpushlocation-oncomplete-onabort">router.push(location, onComplete?, onAbort?)<a class="anchor" href="#routerpushlocation-oncomplete-onabort">§</a></h4>\n<p>注意：在 <code>Vue</code> 实例内部，你可以通过 <code>$router</code> 访问路由实例。因此你可以调用 <code>this.$router.push</code>。</p>\n<p>想要导航到不同的 <code>URL</code>，则使用 <code>router.push</code> 方法。这个方法会向 <code>history</code> 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</p>\n<p>当你点击 <code>&lt;router-link&gt; </code>时，这个方法会在内部调用，所以说，点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 等同于调用 <code>router.push(...)</code>。</p>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>声明式</th>\n<th>编程式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td>\n<td>router.push(...)</td>\n</tr>\n</tbody>\n</table></div>\n<p>该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 字符串</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token string">\'home\'</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 对象</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">\'home\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 命名的路由</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">\'user\'</span><span class="token punctuation">,</span> params<span class="token operator">:</span> <span class="token punctuation">{</span> userId<span class="token operator">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 带查询参数，变成 /register?plan=private</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">\'register\'</span><span class="token punctuation">,</span> query<span class="token operator">:</span> <span class="token punctuation">{</span> plan<span class="token operator">:</span> <span class="token string">\'private\'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p><strong>注意：如果提供了 <code>path</code>，<code>params</code> 会被忽略，上述例子中的 <code>query</code> 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 <code>name</code> 或手写完整的带有参数的 <code>path</code> ：</strong></p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> userId <span class="token operator">=</span> <span class="token number">123</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">\'user\'</span><span class="token punctuation">,</span> params<span class="token operator">:</span> <span class="token punctuation">{</span> userId <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// -> /user/123</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/user/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>userId<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// -> /user/123</span>\n<span class="token comment">// 这里的params不生效</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">\'user\'</span><span class="token punctuation">,</span> params<span class="token operator">:</span> <span class="token punctuation">{</span> userId <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// -> /user</span>\n</code></pre>\n<p>同样的规则也适用于 <code>router-link</code> 组件的 <code>to</code> 属性。</p>\n<p>在 2.2.0+，可选的在 <code>router.push</code> 或 <code>router.replace</code> 中提供 <code>onComplete</code> 和 <code>onAbort</code> 回调作为第二个和第三个参数。这些回调将会在导航成功完成 (在所有的异步钩子被解析之后) 或终止 (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的调用。在 3.1.0+，可以省略第二个和第三个参数，此时如果支持 <code>Promise</code>，<code>router.push</code> 或 <code>router.replace</code> 将返回一个 <code>Promise</code>。</p>\n<p>注意： 如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个 /users/1 -&gt; /users/2)，你需要使用 <code>beforeRouteUpdate</code> 来响应这个变化 (比如抓取用户信息)。</p>\n<h4 id="routerreplacelocation-oncomplete-onabort">router.replace(location, onComplete?, onAbort?)<a class="anchor" href="#routerreplacelocation-oncomplete-onabort">§</a></h4>\n<p>跟 <code>router.push</code> 很像，唯一的不同就是，它不会向 <code>history</code> 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 <code>history</code> 记录。</p>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>声明式</th>\n<th>编程式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&lt;router-link :to=&quot;...&quot; replace&gt;</code></td>\n<td>router.replace(...)</td>\n</tr>\n</tbody>\n</table></div>\n<h4 id="routergon">router.go(n)<a class="anchor" href="#routergon">§</a></h4>\n<p>这个方法的参数是一个整数，意思是在 <code>history</code> 记录中向前或者后退多少步，类似<code> window.history.go(n)</code>。</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 在浏览器记录中前进一步，等同于history.forward()</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">go</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 后退一步记录，等同于history.back()</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">go</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 前进3步记录</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">go</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 如果history记录不够用，则失败</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">go</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">go</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">100</span><span class="token punctuation">)</span>\n</code></pre>\n<h4 id="%E6%93%8D%E4%BD%9C-history">操作 History<a class="anchor" href="#%E6%93%8D%E4%BD%9C-history">§</a></h4>\n<p>你也许注意到 <code>router.push</code>、 <code>router.replace</code> 和 <code>router.go</code> 跟 <code>window.history.pushState</code>、 <code>window.history.replaceState</code> 和 <code>window.history.go</code>好像， 实际上它们确实是效仿 <code>window.history API</code> 的。</p>\n<p>还有值得提及的，<code>Vue Router</code> 的导航方法 (<code>push、 replace、 go</code>) 在各类路由模式 (<code>history、 hash 和 abstract</code>) 下表现一致。</p>\n<h3 id="%E5%91%BD%E5%90%8D%E8%B7%AF%E7%94%B1">命名路由<a class="anchor" href="#%E5%91%BD%E5%90%8D%E8%B7%AF%E7%94%B1">§</a></h3>\n<p>有时候，通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。你可以在创建 <code>Router</code> 实例的时候，在 <code>routes</code> 配置中给某个路由设置名称。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n            path<span class="token operator">:</span> <span class="token string">\'/user/:userId\'</span><span class="token punctuation">,</span>\n            name<span class="token operator">:</span> <span class="token string">\'user\'</span><span class="token punctuation">,</span>\n            component<span class="token operator">:</span> <span class="token maybe-class-name">User</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>要链接到一个命名路由，可以给 <code>router-link</code> 的 <code>to</code> 属性传一个对象：</p>\n<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">:to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{ name: <span class="token punctuation">\'</span>user<span class="token punctuation">\'</span>, params: { userId: 123 } }<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>User<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span>\n</code></pre>\n<p>这跟代码调用 <code>router.push()</code> 是一回事：</p>\n<pre class="language-js"><code class="language-js">router<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">\'user\'</span><span class="token punctuation">,</span> params<span class="token operator">:</span> <span class="token punctuation">{</span> userId<span class="token operator">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>这两种方式都会把路由导航到 <code>/user/123</code> 路径。</p>\n<h3 id="%E5%91%BD%E5%90%8D%E8%A7%86%E5%9B%BE">命名视图<a class="anchor" href="#%E5%91%BD%E5%90%8D%E8%A7%86%E5%9B%BE">§</a></h3>\n<p>有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 <code>sidebar</code> (侧导航) 和 <code>main</code> (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 <code>router-view</code> 没有设置名字，那么默认为 <code>default</code></p>\n<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>view one<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>view two<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>a<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>view three<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>b<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span>\n</code></pre>\n<p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 <code>components</code> 配置 (带上 s)：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n            path<span class="token operator">:</span> <span class="token string">\'/\'</span><span class="token punctuation">,</span>\n            components<span class="token operator">:</span> <span class="token punctuation">{</span>\n                <span class="token keyword module">default</span><span class="token operator">:</span> <span class="token maybe-class-name">Foo</span><span class="token punctuation">,</span>\n                a<span class="token operator">:</span> <span class="token maybe-class-name">Bar</span><span class="token punctuation">,</span>\n                b<span class="token operator">:</span> <span class="token maybe-class-name">Baz</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h4 id="%E5%B5%8C%E5%A5%97%E5%91%BD%E5%90%8D%E8%A7%86%E5%9B%BE">嵌套命名视图<a class="anchor" href="#%E5%B5%8C%E5%A5%97%E5%91%BD%E5%90%8D%E8%A7%86%E5%9B%BE">§</a></h4>\n<p>我们也有可能使用命名视图创建嵌套视图的复杂布局。这时你也需要命名用到的嵌套 <code>router-view</code> 组件。我们以一个设置面板为例：</p>\n<pre class="language-js"><code class="language-js"><span class="token operator">/</span>settings<span class="token operator">/</span>emails                                       <span class="token operator">/</span>settings<span class="token operator">/</span>profile\n<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>                  <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>\n<span class="token operator">|</span> <span class="token maybe-class-name">UserSettings</span>                      <span class="token operator">|</span>                  <span class="token operator">|</span> <span class="token maybe-class-name">UserSettings</span>                 <span class="token operator">|</span>\n<span class="token operator">|</span> <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span> <span class="token operator">|</span>                  <span class="token operator">|</span> <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span> <span class="token operator">|</span>\n<span class="token operator">|</span> <span class="token operator">|</span> <span class="token maybe-class-name">Nav</span> <span class="token operator">|</span> <span class="token maybe-class-name">UserEmailsSubscriptions</span> <span class="token operator">|</span> <span class="token operator">|</span>  <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">></span>  <span class="token operator">|</span> <span class="token operator">|</span> <span class="token maybe-class-name">Nav</span> <span class="token operator">|</span> <span class="token maybe-class-name">UserProfile</span>        <span class="token operator">|</span> <span class="token operator">|</span>\n<span class="token operator">|</span> <span class="token operator">|</span>     <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span> <span class="token operator">|</span>                  <span class="token operator">|</span> <span class="token operator">|</span>     <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span> <span class="token operator">|</span>\n<span class="token operator">|</span> <span class="token operator">|</span>     <span class="token operator">|</span>                         <span class="token operator">|</span> <span class="token operator">|</span>                  <span class="token operator">|</span> <span class="token operator">|</span>     <span class="token operator">|</span> <span class="token maybe-class-name">UserProfilePreview</span> <span class="token operator">|</span> <span class="token operator">|</span>\n<span class="token operator">|</span> <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span> <span class="token operator">|</span>                  <span class="token operator">|</span> <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span> <span class="token operator">|</span>\n<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>                  <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>\n</code></pre>\n<ul>\n<li>Nav 只是一个常规组件。</li>\n<li>UserSettings 是一个视图组件。</li>\n<li>UserEmailsSubscriptions、UserProfile、UserProfilePreview 是嵌套的视图组件。</li>\n</ul>\n<p>注意：我们先忘记 HTML/CSS 具体的布局的样子，只专注在用到的组件上。</p>\n<p>UserSettings 组件的 <code>&lt;template&gt;</code> 部分应该是类似下面的这段代码：</p>\n<pre class="language-html"><code class="language-html"><span class="token comment">&lt;!-- UserSettings.vue --></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>User Settings<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>NavBar</span> <span class="token punctuation">/></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span> <span class="token punctuation">/></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>helper<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre>\n<p>嵌套的视图组件在此已经被忽略了</p>\n<p>然后你可以用这个路由配置完成该布局：</p>\n<pre class="language-js"><code class="language-js"><span class="token punctuation">{</span>\n    path<span class="token operator">:</span> <span class="token string">\'/settings\'</span><span class="token punctuation">,</span>\n    <span class="token comment">// 你也可以在顶级路由就配置命名视图</span>\n    component<span class="token operator">:</span> <span class="token maybe-class-name">UserSettings</span><span class="token punctuation">,</span>\n    children<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n            path<span class="token operator">:</span> <span class="token string">\'emails\'</span><span class="token punctuation">,</span>\n            component<span class="token operator">:</span> <span class="token maybe-class-name">UserEmvilsSubscriptions</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span>\n        <span class="token punctuation">{</span>\n            path<span class="token operator">:</span> <span class="token string">\'profile\'</span><span class="token punctuation">,</span>\n            components <span class="token punctuation">{</span>\n                <span class="token keyword module">default</span><span class="token operator">:</span> <span class="token maybe-class-name">UserProfile</span><span class="token punctuation">,</span>\n                helper<span class="token operator">:</span> <span class="token maybe-class-name">UserProfilePreview</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h3 id="%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E5%88%AB%E5%90%8D">重定向和别名<a class="anchor" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E5%88%AB%E5%90%8D">§</a></h3>\n<h4 id="%E9%87%8D%E5%AE%9A%E5%90%91">重定向<a class="anchor" href="#%E9%87%8D%E5%AE%9A%E5%90%91">§</a></h4>\n<p>重定向也是通过 <code>routes</code> 配置来完成，下面例子是从<code> /a</code> 重定向到<code> /b</code>：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n            path<span class="token operator">:</span> <span class="token string">\'/a\'</span><span class="token punctuation">,</span>\n            redirect<span class="token operator">:</span> <span class="token string">\'/b\'</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>重定向的目标也可以是一个命名的路由：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n            path<span class="token operator">:</span> <span class="token string">\'/a\'</span><span class="token punctuation">,</span>\n            redirect<span class="token operator">:</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">\'foo\'</span> <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>甚至是一个方法，动态返回重定向目标：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n            path<span class="token operator">:</span> <span class="token string">\'/a\'</span><span class="token punctuation">,</span>\n            <span class="token function-variable function">redirect</span><span class="token operator">:</span> <span class="token parameter">to</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n                <span class="token comment">// 方法接收 目标路由 作为参数</span>\n                <span class="token comment">// return 重定向的 字符串路径/路径对象</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>注意导航守卫并没有应用在跳转路由上，而仅仅应用在其目标上。</p>\n<h4 id="%E5%88%AB%E5%90%8D">别名<a class="anchor" href="#%E5%88%AB%E5%90%8D">§</a></h4>\n<p>“重定向”的意思是，当用户访问 <code>/a</code>时，<code>URL </code>将会被替换成<code> /b</code>，然后匹配路由为 <code>/b</code>，那么“别名”又是什么呢？</p>\n<p><code>/a</code> 的别名是 <code>/b</code>，意味着，当用户访问 <code>/b</code> 时，<code>URL</code> 会保持为 <code>/b</code>，但是路由匹配则为 <code>/a</code>，就像用户访问 <code>/a</code> 一样。</p>\n<p>上面对应的路由配置为：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n            path<span class="token operator">:</span> <span class="token string">\'/a\'</span><span class="token punctuation">,</span>\n            component<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">,</span>\n            alis<span class="token operator">:</span> <span class="token string">\'/b\'</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>“别名”的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构。</p>\n<h3 id="%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82">路由组件传参<a class="anchor" href="#%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82">§</a></h3>\n<p>在组件中使用 <code>$route</code> 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 <code>URL</code> 上使用，限制了其灵活性。</p>\n<p>使用 <code>props</code> 将组件和路由解耦：</p>\n<p>取代与 <code>$route</code> 的耦合</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">User</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n    template<span class="token operator">:</span> <span class="token string">\'&lt;div>User {{ $route.params.id }}&lt;/div>\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n            path<span class="token operator">:</span> <span class="token string">\'/user/:id\'</span><span class="token punctuation">,</span>\n            componet<span class="token operator">:</span> <span class="token maybe-class-name">User</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>通过<code>props</code>解耦</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">User</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n    props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">\'id\'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n    template<span class="token operator">:</span> <span class="token string">\'&lt;div>User {{ id }}&lt;/div>\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">\'/user/:id\'</span><span class="token punctuation">,</span> component<span class="token operator">:</span> <span class="token maybe-class-name">User</span><span class="token punctuation">,</span> props<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n        <span class="token comment">// 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：</span>\n        <span class="token punctuation">{</span>\n            path<span class="token operator">:</span> <span class="token string">\'/user/:id\'</span><span class="token punctuation">,</span>\n            components<span class="token operator">:</span> <span class="token punctuation">{</span>\n                <span class="token keyword module">default</span><span class="token operator">:</span> <span class="token maybe-class-name">User</span><span class="token punctuation">,</span>\n                sidebar<span class="token operator">:</span> <span class="token maybe-class-name">Sidebar</span>\n            <span class="token punctuation">}</span><span class="token punctuation">,</span>\n            props<span class="token operator">:</span> <span class="token punctuation">{</span>\n                <span class="token keyword module">default</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n                sidebar<span class="token operator">:</span> <span class="token boolean">false</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>这样你便可以在任何地方使用该组件，使得该组件更易于重用和测试。</p>\n<h4 id="%E5%B8%83%E5%B0%94%E6%A8%A1%E5%BC%8F">布尔模式<a class="anchor" href="#%E5%B8%83%E5%B0%94%E6%A8%A1%E5%BC%8F">§</a></h4>\n<p>如果 <code>props</code> 被设置为 <code>true</code>，<code>route.params</code> 将会被设置为组件属性</p>\n<h4 id="%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F">对象模式<a class="anchor" href="#%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F">§</a></h4>\n<p>如果 <code>props</code> 是一个对象，它会被按原样设置为组件属性。当 <code>props</code> 是静态的时候有用。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span> \n            path<span class="token operator">:</span> <span class="token string">\'/search\'</span><span class="token punctuation">,</span> \n            component<span class="token operator">:</span> <span class="token maybe-class-name">SearchUser</span><span class="token punctuation">,</span> \n            <span class="token function-variable function">props</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">route</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> query<span class="token operator">:</span> route<span class="token punctuation">.</span><span class="token property-access">query</span><span class="token punctuation">.</span><span class="token property-access">q</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>URL <code>/search?q=vue </code>会将 <code>{query: \'vue\'}</code> 作为属性传递给 <code>SearchUser</code> 组件。</p>\n<p>请尽可能保持 <code>props</code> 函数为无状态的，因为它只会在路由发生变化时起作用。如果你需要状态来定义 <code>props</code>，请使用包装组件，这样 <code>Vue</code> 才可以对状态变化做出反应。</p>\n<h3 id="html5-history-%E6%A8%A1%E5%BC%8F">HTML5 History 模式<a class="anchor" href="#html5-history-%E6%A8%A1%E5%BC%8F">§</a></h3>\n<p><code>vue-router</code> 默认 <code>hash</code> 模式 —— 使用 <code>URL</code> 的 <code>hash</code> 来模拟一个完整的 <code>URL</code>，于是当 <code>URL</code> 改变时，页面不会重新加载。</p>\n<p>如果不想要很丑的 <code>hash</code>，我们可以用路由的 <code>history</code> 模式，这种模式充分利用 <code>history.pushState API</code> 来完成 <code>URL</code> 跳转而无须重新加载页面。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    mode<span class="token operator">:</span> <span class="token string">\'history\'</span><span class="token punctuation">,</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token spread operator">...</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>当你使用 <code>history</code> 模式时，<code>URL</code> 就像正常的 url，例如 <code>http://yoursite.com/user/id</code>，也好看！</p>\n<p>不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 <a href="http://oursite.com/user/id">http://oursite.com/user/id</a> 就会返回 404，这就不好看了。</p>\n<p>所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</p>\n<h2 id="%E8%BF%9B%E9%98%B6">进阶<a class="anchor" href="#%E8%BF%9B%E9%98%B6">§</a></h2>\n<h3 id="%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB">导航守卫<a class="anchor" href="#%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB">§</a></h3>\n<p>正如其名，<code>vue-router</code> 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。</p>\n<p>记住<strong>参数或查询的改变并不会触发进入/离开的导航守卫</strong>。你可以通过观察 <code>$route</code> 对象来应对这些变化，或使用 <code>beforeRouteUpdate</code> 的组件内守卫。</p>\n<h4 id="%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB">全局前置守卫<a class="anchor" href="#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB">§</a></h4>\n<p>你可以使用 <code>router.beforeEach</code> 注册一个全局前置守卫：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token spread operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n\nrouter<span class="token punctuation">.</span><span class="token method function property-access">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n    <span class="token comment">// ...</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 <code>resolve</code> 完之前一直处于 等待中。</p>\n<p>每个守卫方法接收三个参数：</p>\n<ul>\n<li>to：Route：即将要进入的目标 路由对象</li>\n<li>from：Route：当前导航正要离开的路由</li>\n<li>next：Function：一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。\n<ul>\n<li>next()：进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed（确认的）。</li>\n<li>next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。</li>\n<li>next(\'/\') 或者 next({ path: \'/\' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: \'home\' 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。</li>\n<li>next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。</li>\n</ul>\n</li>\n</ul>\n<p>确保 <code>next</code> 函数在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错。这里有一个在用户未能验证身份时重定向到 <code>/login</code> 的示例：</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// BAD</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>to<span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">!==</span> <span class="token string">\'Login\'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isAuthenticated<span class="token punctuation">)</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">\'Login\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token comment">// 如果用户未能验证身份，则next会被调用两次</span>\n    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<pre class="language-js"><code class="language-js"><span class="token comment">// GOOD</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>to<span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">!==</span> <span class="token string">\'Login\'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isAuthenticated<span class="token punctuation">)</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">\'Login\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token keyword control-flow">else</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h4 id="%E5%85%A8%E5%B1%80%E8%A7%A3%E6%9E%90%E5%AE%88%E5%8D%AB">全局解析守卫<a class="anchor" href="#%E5%85%A8%E5%B1%80%E8%A7%A3%E6%9E%90%E5%AE%88%E5%8D%AB">§</a></h4>\n<p>在 2.5.0+ 你可以用 <code>router.beforeResolve</code> 注册一个全局守卫。这和 <code>router.beforeEach</code> 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。</p>\n<h4 id="%E5%85%A8%E5%B1%80%E5%90%8E%E7%BD%AE%E9%92%A9%E5%AD%90">全局后置钩子<a class="anchor" href="#%E5%85%A8%E5%B1%80%E5%90%8E%E7%BD%AE%E9%92%A9%E5%AD%90">§</a></h4>\n<p>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身：</p>\n<pre class="language-js"><code class="language-js">router<span class="token punctuation">.</span><span class="token method function property-access">afterEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span></span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h4 id="%E8%B7%AF%E7%94%B1%E7%8B%AC%E4%BA%AB%E7%9A%84%E5%AE%88%E5%8D%AB">路由独享的守卫<a class="anchor" href="#%E8%B7%AF%E7%94%B1%E7%8B%AC%E4%BA%AB%E7%9A%84%E5%AE%88%E5%8D%AB">§</a></h4>\n<p>你可以在路由配置上直接定义 <code>beforeEnter</code> 守卫：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token punctuation">{</span>\n      path<span class="token operator">:</span> <span class="token string">\'/foo\'</span><span class="token punctuation">,</span>\n      component<span class="token operator">:</span> <span class="token maybe-class-name">Foo</span><span class="token punctuation">,</span>\n      <span class="token function-variable function">beforeEnter</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n        <span class="token comment">// ...</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>这些守卫与全局前置守卫的方法参数是一样的。</p>\n<h4 id="%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB">组件内的守卫<a class="anchor" href="#%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB">§</a></h4>\n<p>最后，你可以在路由组件内直接定义以下路由导航守卫：</p>\n<ul>\n<li>beforeRouteEnter</li>\n<li>beforeRouteUpdate (2.2 新增)</li>\n<li>beforeRouteLeave</li>\n</ul>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">Foo</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">...</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>\n  <span class="token function">beforeRouteEnter</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 在渲染该组件的对应路由被 confirm 前调用</span>\n    <span class="token comment">// 不！能！获取组件实例 `this`</span>\n    <span class="token comment">// 因为当守卫执行前，组件实例还没被创建</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function">beforeRouteUpdate</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 在当前路由改变，但是该组件被复用时调用</span>\n    <span class="token comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span>\n    <span class="token comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span>\n    <span class="token comment">// 可以访问组件实例 `this`</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function">beforeRouteLeave</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 导航离开该组件的对应路由时调用</span>\n    <span class="token comment">// 可以访问组件实例 `this`</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p><code>beforeRouteEnter</code> 守卫 不能 访问 <code>this</code>，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。</p>\n<p>不过，你可以通过传一个回调给 <code>next</code>来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p>\n<pre class="language-js"><code class="language-js"><span class="token function">beforeRouteEnter</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">next</span><span class="token punctuation">(</span><span class="token parameter">vm</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n    <span class="token comment">// 通过 `vm` 访问组件实例</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>注意 <code>beforeRouteEnter</code> 是支持给 <code>next</code> 传递回调的唯一守卫。对于 <code>beforeRouteUpdate</code> 和 <code>beforeRouteLeave</code> 来说，<code>this</code> 已经可用了，所以不支持传递回调，因为没有必要了。</p>\n<pre class="language-js"><code class="language-js"><span class="token function">beforeRouteUpdate</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// just use `this`</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">=</span> to<span class="token punctuation">.</span><span class="token property-access">params</span><span class="token punctuation">.</span><span class="token property-access">name</span>\n  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 <code>next(false)</code> 来取消。</p>\n<pre class="language-js"><code class="language-js"><span class="token function">beforeRouteLeave</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> answer <span class="token operator">=</span> <span class="token dom variable">window</span><span class="token punctuation">.</span><span class="token method function property-access">confirm</span><span class="token punctuation">(</span><span class="token string">\'Do you really want to leave? you have unsaved changes!\'</span><span class="token punctuation">)</span>\n  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>answer<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n    <span class="token function">next</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h4 id="%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B">完整的导航解析流程<a class="anchor" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B">§</a></h4>\n<ol>\n<li>导航被触发。</li>\n<li>在失活的组件里调用 beforeRouteLeave 守卫。</li>\n<li>调用全局的 beforeEach 守卫。</li>\n<li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li>\n<li>在路由配置里调用 beforeEnter。</li>\n<li>解析异步路由组件。</li>\n<li>在被激活的组件里调用 beforeRouteEnter。</li>\n<li>调用全局的 beforeResolve 守卫 (2.5+)。</li>\n<li>导航被确认。</li>\n<li>调用全局的 afterEach 钩子。</li>\n<li>触发 DOM 更新。</li>\n<li>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li>\n</ol>\n<h3 id="%E8%B7%AF%E7%94%B1%E5%85%83%E4%BF%A1%E6%81%AF">路由元信息<a class="anchor" href="#%E8%B7%AF%E7%94%B1%E5%85%83%E4%BF%A1%E6%81%AF">§</a></h3>\n<p>定义路由的时候可以配置 <code>meta</code> 字段：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token punctuation">{</span>\n      path<span class="token operator">:</span> <span class="token string">\'/foo\'</span><span class="token punctuation">,</span>\n      component<span class="token operator">:</span> <span class="token maybe-class-name">Foo</span><span class="token punctuation">,</span>\n      children<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n          path<span class="token operator">:</span> <span class="token string">\'bar\'</span><span class="token punctuation">,</span>\n          component<span class="token operator">:</span> <span class="token maybe-class-name">Bar</span><span class="token punctuation">,</span>\n          <span class="token comment">// a meta field</span>\n          meta<span class="token operator">:</span> <span class="token punctuation">{</span> requiresAuth<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">]</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>那么如何访问这个 <code>meta</code> 字段呢？</p>\n<p>首先，我们称呼 <code>routes</code> 配置中的每个路由对象为 路由记录。路由记录可以是嵌套的，因此，当一个路由匹配成功后，他可能匹配多个路由记录</p>\n<p>例如，根据上面的路由配置，/foo/bar 这个 URL 将会匹配父路由记录以及子路由记录。</p>\n<p>一个路由匹配到的所有路由记录会暴露为 <code>$route</code> 对象 (还有在导航守卫中的路由对象) 的 <code>$route.matched</code> 数组。因此，我们需要遍历 <code>$route.matched</code> 来检查路由记录中的 <code>meta</code> 字段。</p>\n<p>下面例子展示在全局导航守卫中检查元字段：</p>\n<pre class="language-js"><code class="language-js">router<span class="token punctuation">.</span><span class="token method function property-access">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>to<span class="token punctuation">.</span><span class="token property-access">matched</span><span class="token punctuation">.</span><span class="token method function property-access">some</span><span class="token punctuation">(</span>record<span class="token punctuation">.</span><span class="token property-access">meta</span><span class="token punctuation">.</span><span class="token property-access">requireAuth</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// this route requires auth, check if logged in</span>\n        <span class="token comment">// if not, redirect to login page.</span>\n        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>auth<span class="token punctuation">.</span><span class="token method function property-access">loggedIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n                path<span class="token operator">:</span> <span class="token string">\'/login\'</span><span class="token punctuation">,</span>\n                query<span class="token operator">:</span> <span class="token punctuation">{</span> redirect<span class="token operator">:</span> to<span class="token punctuation">.</span><span class="token property-access">fullPath</span> <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span><span class="token punctuation">)</span>\n        <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n            <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n        <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 确保一定要调用 next()</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h3 id="%E8%BF%87%E6%B8%A1%E5%8A%A8%E6%95%88">过渡动效<a class="anchor" href="#%E8%BF%87%E6%B8%A1%E5%8A%A8%E6%95%88">§</a></h3>\n<p><code>&lt;router-view&gt;</code> 是基本的动态组件，所以我们可以用 <code>&lt;transition&gt;</code> 组件给它添加一些过渡效果（同vue中的transition）：</p>\n<pre class="language-js"><code class="language-js"><span class="token operator">&lt;</span>transition<span class="token operator">></span>\n    <span class="token operator">&lt;</span>router<span class="token operator">-</span>view<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">></span>\n<span class="token operator">&lt;</span><span class="token operator">/</span>transition<span class="token operator">></span>\n</code></pre>\n<h4 id="%E5%8D%95%E4%B8%AA%E8%B7%AF%E7%94%B1%E7%9A%84%E8%BF%87%E6%B8%A1">单个路由的过渡<a class="anchor" href="#%E5%8D%95%E4%B8%AA%E8%B7%AF%E7%94%B1%E7%9A%84%E8%BF%87%E6%B8%A1">§</a></h4>\n<p>上面的用法会给所有路由设置一样的过渡效果，如果你想让每个路由组件有各自的过渡效果，可以在各路由组件内使用 <code>&lt;transition&gt;</code> 并设置不同的 <code>name</code>。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">Foo</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n    template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">\n        &lt;transition name="slide">\n            &lt;div class="foo">...&lt;/div>\n        &lt;/transition>\n    </span><span class="token template-punctuation string">`</span></span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> <span class="token maybe-class-name">Bar</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n    template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">\n        &lt;transition name="fade">\n            &lt;div class="bar">...&lt;/div>\n        &lt;/transition>\n    </span><span class="token template-punctuation string">`</span></span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h4 id="%E5%9F%BA%E4%BA%8E%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8A%A8%E6%80%81%E8%BF%87%E6%B8%A1">基于路由的动态过渡<a class="anchor" href="#%E5%9F%BA%E4%BA%8E%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8A%A8%E6%80%81%E8%BF%87%E6%B8%A1">§</a></h4>\n<p>还可以基于当前路由与目标路由的变化关系，动态设置过渡效果：</p>\n<pre class="language-html"><code class="language-html"><span class="token comment">&lt;!-- 使用动态的 transition name --></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transition</span> <span class="token attr-name">:name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>transitionName<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transition</span><span class="token punctuation">></span></span>\n</code></pre>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 接着在父组件内</span>\n<span class="token comment">// watch $route 决定使用哪种过渡</span>\nwatch<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token string">\'$route\'</span> <span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> toDepth <span class="token operator">=</span> to<span class="token punctuation">.</span><span class="token property-access">path</span><span class="token punctuation">.</span><span class="token method function property-access">split</span><span class="token punctuation">(</span><span class="token string">\'/\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">length</span>\n    <span class="token keyword">const</span> fromDepth <span class="token operator">=</span> <span class="token keyword module">from</span><span class="token punctuation">.</span><span class="token property-access">path</span><span class="token punctuation">.</span><span class="token method function property-access">split</span><span class="token punctuation">(</span><span class="token string">\'/\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">length</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">transitionName</span> <span class="token operator">=</span> toDepth <span class="token operator">&lt;</span> fromDepth <span class="token operator">?</span> <span class="token string">\'slide-right\'</span> <span class="token operator">:</span> <span class="token string">\'slide-left\'</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h3 id="%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96">数据获取<a class="anchor" href="#%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96">§</a></h3>'
        } }),
    'head': React.createElement("link", { href: "/favicon.png", rel: "icon", type: "image/png" }),
    'script': React.createElement(React.Fragment, null,
        React.createElement("script", { src: "https://cdn.pagic.org/react@16.13.1/umd/react.production.min.js" }),
        React.createElement("script", { src: "https://cdn.pagic.org/react-dom@16.13.1/umd/react-dom.production.min.js" }),
        React.createElement("script", { src: "/index.js", type: "module" })),
    'contentTitle': React.createElement("h1", { key: "0" }, "Vue Router"),
    'contentBody': React.createElement("article", { dangerouslySetInnerHTML: {
            __html: '<h2 id="%E5%9F%BA%E7%A1%80">基础<a class="anchor" href="#%E5%9F%BA%E7%A1%80">§</a></h2>\n<h3 id="%E8%B5%B7%E6%AD%A5">起步<a class="anchor" href="#%E8%B5%B7%E6%AD%A5">§</a></h3>\n<p>用 Vue.js + Vue Router 创建单页应用，感觉很自然：使用 Vue.js ，我们已经可以通过组合组件来组成应用程序，当你要把 Vue Router 添加进来，我们需要做的是，将组件 (components) 映射到路由 (routes)，然后告诉 Vue Router 在哪里渲染它们。下面是个基本例子：</p>\n<h4 id="html">HTML<a class="anchor" href="#html">§</a></h4>\n<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><a class="token url-link" href="https://unpkg.com/vue/dist/vue.js">https://unpkg.com/vue/dist/vue.js</a><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><a class="token url-link" href="https://unpkg.com/vue-router/dist/vue-router.js">https://unpkg.com/vue-router/dist/vue-router.js</a><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Hello App!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>\n    <span class="token comment">&lt;!-- 使用 router-link 组件来导航. --></span>\n    <span class="token comment">&lt;!-- 通过传入 `to` 属性指定链接. --></span>\n    <span class="token comment">&lt;!-- &lt;router-link> 默认会被渲染成一个 `&lt;a>` 标签 --></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/foo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Go to Foo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/bar<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Go to Bar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>\n  <span class="token comment">&lt;!-- 路由出口 --></span>\n  <span class="token comment">&lt;!-- 路由匹配到的组件将渲染在这里 --></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre>\n<h4 id="javascript">JavaScript<a class="anchor" href="#javascript">§</a></h4>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)</span>\n\n<span class="token comment">// 1. 定义 (路由) 组件。</span>\n<span class="token comment">// 可以从其他文件 import 进来</span>\n<span class="token keyword">const</span> <span class="token maybe-class-name">Foo</span> <span class="token operator">=</span> <span class="token punctuation">{</span> template<span class="token operator">:</span> <span class="token string">\'&lt;div>foo&lt;/div>\'</span> <span class="token punctuation">}</span>\n<span class="token keyword">const</span> <span class="token maybe-class-name">Bar</span> <span class="token operator">=</span> <span class="token punctuation">{</span> template<span class="token operator">:</span> <span class="token string">\'&lt;div>bar&lt;/div>\'</span> <span class="token punctuation">}</span>\n\n<span class="token comment">// 2. 定义路由</span>\n<span class="token comment">// 每个路由应该映射一个组件。 其中"component" 可以是</span>\n<span class="token comment">// 通过 Vue.extend() 创建的组件构造器，</span>\n<span class="token comment">// 或者，只是一个组件配置对象。</span>\n<span class="token comment">// 我们晚点再讨论嵌套路由。</span>\n<span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>\n  <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">\'/foo\'</span><span class="token punctuation">,</span> component<span class="token operator">:</span> <span class="token maybe-class-name">Foo</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">\'/bar\'</span><span class="token punctuation">,</span> component<span class="token operator">:</span> <span class="token maybe-class-name">Bar</span> <span class="token punctuation">}</span>\n<span class="token punctuation">]</span>\n\n<span class="token comment">// 3. 创建 router 实例，然后传 `routes` 配置</span>\n<span class="token comment">// 你还可以传别的配置参数, 不过先这么简单着吧。</span>\n<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  routes <span class="token comment">// (缩写) 相当于 routes: routes</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 4. 创建和挂载根实例。</span>\n<span class="token comment">// 记得要通过 router 配置参数注入路由，</span>\n<span class="token comment">// 从而让整个应用都有路由功能</span>\n<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  router\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">$mount</span><span class="token punctuation">(</span><span class="token string">\'#app\'</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 现在，应用已经启动了！</span>\n</code></pre>\n<p>通过注入路由器，我们可以在任何组件内通过 <code>this.$router</code> 访问路由器，也可以通过 <code>this.$route</code> 访问当前路由：</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// Home.vue</span>\n<span class="token keyword module">export</span> <span class="token keyword module">default</span> <span class="token punctuation">{</span>\n    computed<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token function">username</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 我们很快就会看到 `params` 是什么</span>\n            <span class="token keyword control-flow">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$route</span><span class="token punctuation">.</span><span class="token property-access">params</span><span class="token punctuation">.</span><span class="token property-access">username</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    methods<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token function">goBack</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token dom variable">window</span><span class="token punctuation">.</span><span class="token property-access">history</span><span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$router</span><span class="token punctuation">.</span><span class="token method function property-access">go</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$router</span><span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token string">\'/\'</span><span class="token punctuation">)</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>要注意，当 <code>&lt;router-link&gt;</code> 对应的路由匹配成功，将自动设置 <code>class</code> 属性值 <code>.router-link-active</code>。</p>\n<h3 id="%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D">动态路由匹配<a class="anchor" href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D">§</a></h3>\n<p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 <code>User</code> 组件，对于所有 <code>ID</code> 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 <code>vue-router</code> 的路由路径中使用<code>“动态路径参数”(dynamic segment)</code> 来达到这个效果：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">User</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n    template<span class="token operator">:</span> <span class="token string">\'&lt;div>User&lt;/div>\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token comment">// 动态路径参数 以冒号开头</span>\n        <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">\'/user/:id\'</span><span class="token punctuation">,</span> component<span class="token operator">:</span> <span class="token maybe-class-name">User</span> <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>现在呢，像 <code>/user/foo</code> 和 <code>/user/bar</code> 都将映射到相同的路由。</p>\n<p>一个“路径参数”使用冒号<code>:</code>标记。当匹配到一个路由时，参数值会被设置到 <code>this.$route.params</code>，可以在每个组件内使用。于是，我们可以更新 <code>User</code> 的模板，输出当前用户的 <code>ID：</code></p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">User</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n    template<span class="token operator">:</span> <span class="token string">\'&lt;div>{{ this.$route.params.id }}&lt;/div>\'</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>你可以在一个路由中设置多段“路径参数”，对应的值都会设置到<code>$route.params</code>中。例如：</p>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>模式</th>\n<th>匹配路径</th>\n<th>$route.params</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/user/:username</td>\n<td>/user/evan</td>\n<td>{ username: \'evan\'</td>\n</tr>\n<tr>\n<td>/user/:username/post/:post_id</td>\n<td>/user/evan/post/123</td>\n<td>{ username: \'evan\', post_id: \'123\' }</td>\n</tr>\n</tbody>\n</table></div>\n<p>除了<code>$route.params</code> 外，<code>$route</code> 对象还提供了其它有用的信息，例如，<code>$route.query</code> (如果 URL 中有查询参数)、<code>$route.hash</code> 等等。</p>\n<h4 id="%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96">响应路由参数的变化<a class="anchor" href="#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96">§</a></h4>\n<p>提醒一下，当使用路由参数时，例如从 <code>/user/foo</code> 导航到 <code>/user/bar</code>，<strong>原来的组件实例会被复用</strong>。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。<strong>不过，这也意味着组件的生命周期钩子不会再被调用。</strong></p>\n<p>复用组件时，想对路由参数的变化作出响应的话，你可以简单地 <code>watch</code> (监测变化) <code>$route</code> 对象：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">User</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n    template<span class="token operator">:</span> <span class="token string">\'...\'</span><span class="token punctuation">,</span>\n    watch<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token function">$route</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// 对路由变化作出响应...</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>或者使用 2.2 中引入的 <code>beforeRouteUpdate</code> 导航守卫：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">User</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n    template<span class="token operator">:</span> <span class="token string">\'...\'</span><span class="token punctuation">,</span>\n    <span class="token function">beforeRouteUpdate</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// react to route changes...</span>\n        <span class="token comment">// don\'t forget to call next()</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h4 id="%E6%8D%95%E8%8E%B7%E6%89%80%E6%9C%89%E8%B7%AF%E7%94%B1%E6%88%96-404-not-found-%E8%B7%AF%E7%94%B1">捕获所有路由或 404 Not found 路由<a class="anchor" href="#%E6%8D%95%E8%8E%B7%E6%89%80%E6%9C%89%E8%B7%AF%E7%94%B1%E6%88%96-404-not-found-%E8%B7%AF%E7%94%B1">§</a></h4>\n<p>常规参数只会匹配被<code>/</code>分隔的 <code>URL</code> 片段中的字符。如果想匹配<strong>任意路径</strong>，我们可以使用<code>通配符 (*)</code>：</p>\n<pre class="language-js"><code class="language-js"><span class="token punctuation">{</span>\n    <span class="token comment">// 匹配所有路径</span>\n    path<span class="token operator">:</span> <span class="token string">\'*\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token punctuation">{</span>\n    <span class="token comment">// 匹配以\'/user-\'开头的任意路径</span>\n    path<span class="token operator">:</span> <span class="token string">\'/user-*\'</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>当使用通配符路由时，请确保路由的顺序是正确的，也就是说含有通配符的路由应该放在最后。路由 <code>{ path: \'*\' } </code>通常用于客户端 404 错误。如果你使用了History 模式，请确保正确配置你的服务器。</p>\n<p>当使用一个通配符时，<code>$route.params</code> 内会自动添加一个名为 <code>pathMatch</code> 参数。它包含了 <code>URL</code> 通过通配符被匹配的部分：</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 给出一个路由 { path: \'/user-*\' }</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$router</span><span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token string">\'/user-admin\'</span><span class="token punctuation">)</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$route</span><span class="token punctuation">.</span><span class="token property-access">params</span><span class="token punctuation">.</span><span class="token property-access">pathMatch</span> <span class="token comment">// \'admin\'</span>\n<span class="token comment">// 给出一个路由 { path: \'*\' }</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$router</span><span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token string">\'/non-existing\'</span><span class="token punctuation">)</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">$route</span><span class="token punctuation">.</span><span class="token property-access">params</span><span class="token punctuation">.</span><span class="token property-access">pathMatch</span> <span class="token comment">// \'/non-existing\'</span>\n</code></pre>\n<h4 id="%E5%8C%B9%E9%85%8D%E4%BC%98%E5%85%88%E7%BA%A7">匹配优先级<a class="anchor" href="#%E5%8C%B9%E9%85%8D%E4%BC%98%E5%85%88%E7%BA%A7">§</a></h4>\n<p>有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。</p>\n<h3 id="%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1">嵌套路由<a class="anchor" href="#%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1">§</a></h3>\n<p>实际生活中的应用界面，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层组件，例如：</p>\n<pre class="language-js"><code class="language-js"><span class="token operator">/</span>user<span class="token operator">/</span>foo<span class="token operator">/</span>profile                     <span class="token operator">/</span>user<span class="token operator">/</span>foo<span class="token operator">/</span>posts\n<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>                  <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>\n<span class="token operator">|</span> <span class="token maybe-class-name">User</span>             <span class="token operator">|</span>                  <span class="token operator">|</span> <span class="token maybe-class-name">User</span>            <span class="token operator">|</span>\n<span class="token operator">|</span> <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span> <span class="token operator">|</span>                  <span class="token operator">|</span> <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span> <span class="token operator">|</span>\n<span class="token operator">|</span> <span class="token operator">|</span> <span class="token maybe-class-name">Profile</span>      <span class="token operator">|</span> <span class="token operator">|</span>  <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">></span>  <span class="token operator">|</span> <span class="token operator">|</span> <span class="token maybe-class-name">Posts</span>       <span class="token operator">|</span> <span class="token operator">|</span>\n<span class="token operator">|</span> <span class="token operator">|</span>              <span class="token operator">|</span> <span class="token operator">|</span>                  <span class="token operator">|</span> <span class="token operator">|</span>             <span class="token operator">|</span> <span class="token operator">|</span>\n<span class="token operator">|</span> <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span> <span class="token operator">|</span>                  <span class="token operator">|</span> <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span> <span class="token operator">|</span>\n<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>                  <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>\n</code></pre>\n<p>借助 vue-router，使用嵌套路由配置，就可以很简单地表达这种关系。</p>\n<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">User</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n  template<span class="token operator">:</span> <span class="token string">\'&lt;div>User {{ $route.params.id }}&lt;/div>\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">\'/user/:id\'</span><span class="token punctuation">,</span> component<span class="token operator">:</span> <span class="token maybe-class-name">User</span> <span class="token punctuation">}</span>\n  <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>这里的<code>&lt;router-view&gt;</code>是最顶层的出口，渲染最高级路由匹配到的组件。同样地，一个被渲染组件同样可以包含自己的嵌套 <code>&lt;router-view&gt;</code>。例如，在 User 组件的模板添加一个 <code>&lt;router-view&gt;</code>：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">User</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n    template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">\n        &lt;div class="user">\n            &lt;h2>User {{ $route.params.id }}&lt;/h2>\n            &lt;router-view>&lt;/router-view>\n        &lt;/div>\n    </span><span class="token template-punctuation string">`</span></span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>要在嵌套的出口中渲染组件，需要在 <code>VueRouter</code> 的参数中使用 <code>children</code> 配置：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRotuer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n            path<span class="token operator">:</span> <span class="token string">\'/user/:id\'</span><span class="token punctuation">,</span>\n            component<span class="token operator">:</span> <span class="token maybe-class-name">User</span><span class="token punctuation">,</span>\n            children<span class="token operator">:</span> <span class="token punctuation">[</span>\n                <span class="token punctuation">{</span>\n                    <span class="token comment">// 当/user/:id/profile匹配成功,</span>\n                    <span class="token comment">// UserProfile会被渲染在User的&lt;router-view>中</span>\n                    path<span class="token operator">:</span> <span class="token string">\'profile\'</span><span class="token punctuation">,</span>\n                    component<span class="token operator">:</span> <span class="token maybe-class-name">UserProfile</span>\n                <span class="token punctuation">}</span><span class="token punctuation">,</span>\n                <span class="token punctuation">{</span>\n                    <span class="token comment">// 当/user/:id/posts匹配成功</span>\n                    <span class="token comment">// UserPosts会被渲染在User的&lt;router-view>中</span>\n                    path<span class="token operator">:</span> <span class="token string">\'posts\'</span><span class="token punctuation">,</span>\n                    component<span class="token operator">:</span> <span class="token maybe-class-name">UserPosts</span>\n                <span class="token punctuation">}</span>\n            <span class="token punctuation">]</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>要注意，以<code>/</code> 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。</p>\n<p>你会发现，<code>children</code> 配置就是像 <code>routes</code> 配置一样的路由配置数组，所以呢，你可以嵌套多层路由。</p>\n<p>此时，基于上面的配置，当你访问 <code>/user/foo</code> 时，<code>User</code> 的出口是不会渲染任何东西，这是因为没有匹配到合适的子路由。如果你想要渲染点什么，可以提供一个 <code>空的</code> 子路由：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n            path<span class="token operator">:</span> <span class="token string">\'/user/:id\'</span><span class="token punctuation">,</span>\n            component<span class="token operator">:</span> <span class="token maybe-class-name">User</span><span class="token punctuation">,</span>\n            children<span class="token operator">:</span> <span class="token punctuation">[</span>\n            <span class="token comment">// 当 /user/:id 匹配成功，</span>\n            <span class="token comment">// UserHome 会被渲染在 User 的 &lt;router-view> 中</span>\n            <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">\'\'</span><span class="token punctuation">,</span> component<span class="token operator">:</span> <span class="token maybe-class-name">UserHome</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n            <span class="token comment">// ...其他子路由</span>\n            <span class="token punctuation">]</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h3 id="%E7%BC%96%E7%A8%8B%E5%BC%8F%E7%9A%84%E5%AF%BC%E8%88%AA">编程式的导航<a class="anchor" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E7%9A%84%E5%AF%BC%E8%88%AA">§</a></h3>\n<p>除了使用 <code>&lt;router-link&gt;</code> 创建 <code>a</code> 标签来定义导航链接，我们还可以借助 <code>router</code> 的实例方法，通过编写代码来实现。</p>\n<h4 id="routerpushlocation-oncomplete-onabort">router.push(location, onComplete?, onAbort?)<a class="anchor" href="#routerpushlocation-oncomplete-onabort">§</a></h4>\n<p>注意：在 <code>Vue</code> 实例内部，你可以通过 <code>$router</code> 访问路由实例。因此你可以调用 <code>this.$router.push</code>。</p>\n<p>想要导航到不同的 <code>URL</code>，则使用 <code>router.push</code> 方法。这个方法会向 <code>history</code> 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</p>\n<p>当你点击 <code>&lt;router-link&gt; </code>时，这个方法会在内部调用，所以说，点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 等同于调用 <code>router.push(...)</code>。</p>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>声明式</th>\n<th>编程式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td>\n<td>router.push(...)</td>\n</tr>\n</tbody>\n</table></div>\n<p>该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 字符串</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token string">\'home\'</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 对象</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">\'home\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 命名的路由</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">\'user\'</span><span class="token punctuation">,</span> params<span class="token operator">:</span> <span class="token punctuation">{</span> userId<span class="token operator">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 带查询参数，变成 /register?plan=private</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">\'register\'</span><span class="token punctuation">,</span> query<span class="token operator">:</span> <span class="token punctuation">{</span> plan<span class="token operator">:</span> <span class="token string">\'private\'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p><strong>注意：如果提供了 <code>path</code>，<code>params</code> 会被忽略，上述例子中的 <code>query</code> 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 <code>name</code> 或手写完整的带有参数的 <code>path</code> ：</strong></p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> userId <span class="token operator">=</span> <span class="token number">123</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">\'user\'</span><span class="token punctuation">,</span> params<span class="token operator">:</span> <span class="token punctuation">{</span> userId <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// -> /user/123</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/user/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>userId<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// -> /user/123</span>\n<span class="token comment">// 这里的params不生效</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">\'user\'</span><span class="token punctuation">,</span> params<span class="token operator">:</span> <span class="token punctuation">{</span> userId <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// -> /user</span>\n</code></pre>\n<p>同样的规则也适用于 <code>router-link</code> 组件的 <code>to</code> 属性。</p>\n<p>在 2.2.0+，可选的在 <code>router.push</code> 或 <code>router.replace</code> 中提供 <code>onComplete</code> 和 <code>onAbort</code> 回调作为第二个和第三个参数。这些回调将会在导航成功完成 (在所有的异步钩子被解析之后) 或终止 (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的调用。在 3.1.0+，可以省略第二个和第三个参数，此时如果支持 <code>Promise</code>，<code>router.push</code> 或 <code>router.replace</code> 将返回一个 <code>Promise</code>。</p>\n<p>注意： 如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个 /users/1 -&gt; /users/2)，你需要使用 <code>beforeRouteUpdate</code> 来响应这个变化 (比如抓取用户信息)。</p>\n<h4 id="routerreplacelocation-oncomplete-onabort">router.replace(location, onComplete?, onAbort?)<a class="anchor" href="#routerreplacelocation-oncomplete-onabort">§</a></h4>\n<p>跟 <code>router.push</code> 很像，唯一的不同就是，它不会向 <code>history</code> 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 <code>history</code> 记录。</p>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>声明式</th>\n<th>编程式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&lt;router-link :to=&quot;...&quot; replace&gt;</code></td>\n<td>router.replace(...)</td>\n</tr>\n</tbody>\n</table></div>\n<h4 id="routergon">router.go(n)<a class="anchor" href="#routergon">§</a></h4>\n<p>这个方法的参数是一个整数，意思是在 <code>history</code> 记录中向前或者后退多少步，类似<code> window.history.go(n)</code>。</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 在浏览器记录中前进一步，等同于history.forward()</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">go</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 后退一步记录，等同于history.back()</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">go</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 前进3步记录</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">go</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 如果history记录不够用，则失败</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">go</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">go</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">100</span><span class="token punctuation">)</span>\n</code></pre>\n<h4 id="%E6%93%8D%E4%BD%9C-history">操作 History<a class="anchor" href="#%E6%93%8D%E4%BD%9C-history">§</a></h4>\n<p>你也许注意到 <code>router.push</code>、 <code>router.replace</code> 和 <code>router.go</code> 跟 <code>window.history.pushState</code>、 <code>window.history.replaceState</code> 和 <code>window.history.go</code>好像， 实际上它们确实是效仿 <code>window.history API</code> 的。</p>\n<p>还有值得提及的，<code>Vue Router</code> 的导航方法 (<code>push、 replace、 go</code>) 在各类路由模式 (<code>history、 hash 和 abstract</code>) 下表现一致。</p>\n<h3 id="%E5%91%BD%E5%90%8D%E8%B7%AF%E7%94%B1">命名路由<a class="anchor" href="#%E5%91%BD%E5%90%8D%E8%B7%AF%E7%94%B1">§</a></h3>\n<p>有时候，通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。你可以在创建 <code>Router</code> 实例的时候，在 <code>routes</code> 配置中给某个路由设置名称。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n            path<span class="token operator">:</span> <span class="token string">\'/user/:userId\'</span><span class="token punctuation">,</span>\n            name<span class="token operator">:</span> <span class="token string">\'user\'</span><span class="token punctuation">,</span>\n            component<span class="token operator">:</span> <span class="token maybe-class-name">User</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>要链接到一个命名路由，可以给 <code>router-link</code> 的 <code>to</code> 属性传一个对象：</p>\n<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">:to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>{ name: <span class="token punctuation">\'</span>user<span class="token punctuation">\'</span>, params: { userId: 123 } }<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>User<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span>\n</code></pre>\n<p>这跟代码调用 <code>router.push()</code> 是一回事：</p>\n<pre class="language-js"><code class="language-js">router<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">\'user\'</span><span class="token punctuation">,</span> params<span class="token operator">:</span> <span class="token punctuation">{</span> userId<span class="token operator">:</span> <span class="token number">123</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>这两种方式都会把路由导航到 <code>/user/123</code> 路径。</p>\n<h3 id="%E5%91%BD%E5%90%8D%E8%A7%86%E5%9B%BE">命名视图<a class="anchor" href="#%E5%91%BD%E5%90%8D%E8%A7%86%E5%9B%BE">§</a></h3>\n<p>有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 <code>sidebar</code> (侧导航) 和 <code>main</code> (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 <code>router-view</code> 没有设置名字，那么默认为 <code>default</code></p>\n<pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>view one<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>view two<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>a<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>view three<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>b<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span>\n</code></pre>\n<p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 <code>components</code> 配置 (带上 s)：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n            path<span class="token operator">:</span> <span class="token string">\'/\'</span><span class="token punctuation">,</span>\n            components<span class="token operator">:</span> <span class="token punctuation">{</span>\n                <span class="token keyword module">default</span><span class="token operator">:</span> <span class="token maybe-class-name">Foo</span><span class="token punctuation">,</span>\n                a<span class="token operator">:</span> <span class="token maybe-class-name">Bar</span><span class="token punctuation">,</span>\n                b<span class="token operator">:</span> <span class="token maybe-class-name">Baz</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h4 id="%E5%B5%8C%E5%A5%97%E5%91%BD%E5%90%8D%E8%A7%86%E5%9B%BE">嵌套命名视图<a class="anchor" href="#%E5%B5%8C%E5%A5%97%E5%91%BD%E5%90%8D%E8%A7%86%E5%9B%BE">§</a></h4>\n<p>我们也有可能使用命名视图创建嵌套视图的复杂布局。这时你也需要命名用到的嵌套 <code>router-view</code> 组件。我们以一个设置面板为例：</p>\n<pre class="language-js"><code class="language-js"><span class="token operator">/</span>settings<span class="token operator">/</span>emails                                       <span class="token operator">/</span>settings<span class="token operator">/</span>profile\n<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>                  <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>\n<span class="token operator">|</span> <span class="token maybe-class-name">UserSettings</span>                      <span class="token operator">|</span>                  <span class="token operator">|</span> <span class="token maybe-class-name">UserSettings</span>                 <span class="token operator">|</span>\n<span class="token operator">|</span> <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span> <span class="token operator">|</span>                  <span class="token operator">|</span> <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span> <span class="token operator">|</span>\n<span class="token operator">|</span> <span class="token operator">|</span> <span class="token maybe-class-name">Nav</span> <span class="token operator">|</span> <span class="token maybe-class-name">UserEmailsSubscriptions</span> <span class="token operator">|</span> <span class="token operator">|</span>  <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">></span>  <span class="token operator">|</span> <span class="token operator">|</span> <span class="token maybe-class-name">Nav</span> <span class="token operator">|</span> <span class="token maybe-class-name">UserProfile</span>        <span class="token operator">|</span> <span class="token operator">|</span>\n<span class="token operator">|</span> <span class="token operator">|</span>     <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span> <span class="token operator">|</span>                  <span class="token operator">|</span> <span class="token operator">|</span>     <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span> <span class="token operator">|</span>\n<span class="token operator">|</span> <span class="token operator">|</span>     <span class="token operator">|</span>                         <span class="token operator">|</span> <span class="token operator">|</span>                  <span class="token operator">|</span> <span class="token operator">|</span>     <span class="token operator">|</span> <span class="token maybe-class-name">UserProfilePreview</span> <span class="token operator">|</span> <span class="token operator">|</span>\n<span class="token operator">|</span> <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span> <span class="token operator">|</span>                  <span class="token operator">|</span> <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span> <span class="token operator">|</span>\n<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>                  <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>\n</code></pre>\n<ul>\n<li>Nav 只是一个常规组件。</li>\n<li>UserSettings 是一个视图组件。</li>\n<li>UserEmailsSubscriptions、UserProfile、UserProfilePreview 是嵌套的视图组件。</li>\n</ul>\n<p>注意：我们先忘记 HTML/CSS 具体的布局的样子，只专注在用到的组件上。</p>\n<p>UserSettings 组件的 <code>&lt;template&gt;</code> 部分应该是类似下面的这段代码：</p>\n<pre class="language-html"><code class="language-html"><span class="token comment">&lt;!-- UserSettings.vue --></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>User Settings<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>NavBar</span> <span class="token punctuation">/></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span> <span class="token punctuation">/></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>helper<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre>\n<p>嵌套的视图组件在此已经被忽略了</p>\n<p>然后你可以用这个路由配置完成该布局：</p>\n<pre class="language-js"><code class="language-js"><span class="token punctuation">{</span>\n    path<span class="token operator">:</span> <span class="token string">\'/settings\'</span><span class="token punctuation">,</span>\n    <span class="token comment">// 你也可以在顶级路由就配置命名视图</span>\n    component<span class="token operator">:</span> <span class="token maybe-class-name">UserSettings</span><span class="token punctuation">,</span>\n    children<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n            path<span class="token operator">:</span> <span class="token string">\'emails\'</span><span class="token punctuation">,</span>\n            component<span class="token operator">:</span> <span class="token maybe-class-name">UserEmvilsSubscriptions</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span>\n        <span class="token punctuation">{</span>\n            path<span class="token operator">:</span> <span class="token string">\'profile\'</span><span class="token punctuation">,</span>\n            components <span class="token punctuation">{</span>\n                <span class="token keyword module">default</span><span class="token operator">:</span> <span class="token maybe-class-name">UserProfile</span><span class="token punctuation">,</span>\n                helper<span class="token operator">:</span> <span class="token maybe-class-name">UserProfilePreview</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h3 id="%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E5%88%AB%E5%90%8D">重定向和别名<a class="anchor" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E5%88%AB%E5%90%8D">§</a></h3>\n<h4 id="%E9%87%8D%E5%AE%9A%E5%90%91">重定向<a class="anchor" href="#%E9%87%8D%E5%AE%9A%E5%90%91">§</a></h4>\n<p>重定向也是通过 <code>routes</code> 配置来完成，下面例子是从<code> /a</code> 重定向到<code> /b</code>：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n            path<span class="token operator">:</span> <span class="token string">\'/a\'</span><span class="token punctuation">,</span>\n            redirect<span class="token operator">:</span> <span class="token string">\'/b\'</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>重定向的目标也可以是一个命名的路由：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n            path<span class="token operator">:</span> <span class="token string">\'/a\'</span><span class="token punctuation">,</span>\n            redirect<span class="token operator">:</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">\'foo\'</span> <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>甚至是一个方法，动态返回重定向目标：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n            path<span class="token operator">:</span> <span class="token string">\'/a\'</span><span class="token punctuation">,</span>\n            <span class="token function-variable function">redirect</span><span class="token operator">:</span> <span class="token parameter">to</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n                <span class="token comment">// 方法接收 目标路由 作为参数</span>\n                <span class="token comment">// return 重定向的 字符串路径/路径对象</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>注意导航守卫并没有应用在跳转路由上，而仅仅应用在其目标上。</p>\n<h4 id="%E5%88%AB%E5%90%8D">别名<a class="anchor" href="#%E5%88%AB%E5%90%8D">§</a></h4>\n<p>“重定向”的意思是，当用户访问 <code>/a</code>时，<code>URL </code>将会被替换成<code> /b</code>，然后匹配路由为 <code>/b</code>，那么“别名”又是什么呢？</p>\n<p><code>/a</code> 的别名是 <code>/b</code>，意味着，当用户访问 <code>/b</code> 时，<code>URL</code> 会保持为 <code>/b</code>，但是路由匹配则为 <code>/a</code>，就像用户访问 <code>/a</code> 一样。</p>\n<p>上面对应的路由配置为：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n            path<span class="token operator">:</span> <span class="token string">\'/a\'</span><span class="token punctuation">,</span>\n            component<span class="token operator">:</span> <span class="token constant">A</span><span class="token punctuation">,</span>\n            alis<span class="token operator">:</span> <span class="token string">\'/b\'</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>“别名”的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构。</p>\n<h3 id="%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82">路由组件传参<a class="anchor" href="#%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82">§</a></h3>\n<p>在组件中使用 <code>$route</code> 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 <code>URL</code> 上使用，限制了其灵活性。</p>\n<p>使用 <code>props</code> 将组件和路由解耦：</p>\n<p>取代与 <code>$route</code> 的耦合</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">User</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n    template<span class="token operator">:</span> <span class="token string">\'&lt;div>User {{ $route.params.id }}&lt;/div>\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n            path<span class="token operator">:</span> <span class="token string">\'/user/:id\'</span><span class="token punctuation">,</span>\n            componet<span class="token operator">:</span> <span class="token maybe-class-name">User</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>通过<code>props</code>解耦</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">User</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n    props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">\'id\'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n    template<span class="token operator">:</span> <span class="token string">\'&lt;div>User {{ id }}&lt;/div>\'</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">\'/user/:id\'</span><span class="token punctuation">,</span> component<span class="token operator">:</span> <span class="token maybe-class-name">User</span><span class="token punctuation">,</span> props<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n        <span class="token comment">// 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：</span>\n        <span class="token punctuation">{</span>\n            path<span class="token operator">:</span> <span class="token string">\'/user/:id\'</span><span class="token punctuation">,</span>\n            components<span class="token operator">:</span> <span class="token punctuation">{</span>\n                <span class="token keyword module">default</span><span class="token operator">:</span> <span class="token maybe-class-name">User</span><span class="token punctuation">,</span>\n                sidebar<span class="token operator">:</span> <span class="token maybe-class-name">Sidebar</span>\n            <span class="token punctuation">}</span><span class="token punctuation">,</span>\n            props<span class="token operator">:</span> <span class="token punctuation">{</span>\n                <span class="token keyword module">default</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n                sidebar<span class="token operator">:</span> <span class="token boolean">false</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>这样你便可以在任何地方使用该组件，使得该组件更易于重用和测试。</p>\n<h4 id="%E5%B8%83%E5%B0%94%E6%A8%A1%E5%BC%8F">布尔模式<a class="anchor" href="#%E5%B8%83%E5%B0%94%E6%A8%A1%E5%BC%8F">§</a></h4>\n<p>如果 <code>props</code> 被设置为 <code>true</code>，<code>route.params</code> 将会被设置为组件属性</p>\n<h4 id="%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F">对象模式<a class="anchor" href="#%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F">§</a></h4>\n<p>如果 <code>props</code> 是一个对象，它会被按原样设置为组件属性。当 <code>props</code> 是静态的时候有用。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span> \n            path<span class="token operator">:</span> <span class="token string">\'/search\'</span><span class="token punctuation">,</span> \n            component<span class="token operator">:</span> <span class="token maybe-class-name">SearchUser</span><span class="token punctuation">,</span> \n            <span class="token function-variable function">props</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">route</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> query<span class="token operator">:</span> route<span class="token punctuation">.</span><span class="token property-access">query</span><span class="token punctuation">.</span><span class="token property-access">q</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>URL <code>/search?q=vue </code>会将 <code>{query: \'vue\'}</code> 作为属性传递给 <code>SearchUser</code> 组件。</p>\n<p>请尽可能保持 <code>props</code> 函数为无状态的，因为它只会在路由发生变化时起作用。如果你需要状态来定义 <code>props</code>，请使用包装组件，这样 <code>Vue</code> 才可以对状态变化做出反应。</p>\n<h3 id="html5-history-%E6%A8%A1%E5%BC%8F">HTML5 History 模式<a class="anchor" href="#html5-history-%E6%A8%A1%E5%BC%8F">§</a></h3>\n<p><code>vue-router</code> 默认 <code>hash</code> 模式 —— 使用 <code>URL</code> 的 <code>hash</code> 来模拟一个完整的 <code>URL</code>，于是当 <code>URL</code> 改变时，页面不会重新加载。</p>\n<p>如果不想要很丑的 <code>hash</code>，我们可以用路由的 <code>history</code> 模式，这种模式充分利用 <code>history.pushState API</code> 来完成 <code>URL</code> 跳转而无须重新加载页面。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    mode<span class="token operator">:</span> <span class="token string">\'history\'</span><span class="token punctuation">,</span>\n    routes<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token spread operator">...</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>当你使用 <code>history</code> 模式时，<code>URL</code> 就像正常的 url，例如 <code>http://yoursite.com/user/id</code>，也好看！</p>\n<p>不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 <a href="http://oursite.com/user/id">http://oursite.com/user/id</a> 就会返回 404，这就不好看了。</p>\n<p>所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</p>\n<h2 id="%E8%BF%9B%E9%98%B6">进阶<a class="anchor" href="#%E8%BF%9B%E9%98%B6">§</a></h2>\n<h3 id="%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB">导航守卫<a class="anchor" href="#%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB">§</a></h3>\n<p>正如其名，<code>vue-router</code> 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的, 单个路由独享的, 或者组件级的。</p>\n<p>记住<strong>参数或查询的改变并不会触发进入/离开的导航守卫</strong>。你可以通过观察 <code>$route</code> 对象来应对这些变化，或使用 <code>beforeRouteUpdate</code> 的组件内守卫。</p>\n<h4 id="%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB">全局前置守卫<a class="anchor" href="#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB">§</a></h4>\n<p>你可以使用 <code>router.beforeEach</code> 注册一个全局前置守卫：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token spread operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n\nrouter<span class="token punctuation">.</span><span class="token method function property-access">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n    <span class="token comment">// ...</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫 <code>resolve</code> 完之前一直处于 等待中。</p>\n<p>每个守卫方法接收三个参数：</p>\n<ul>\n<li>to：Route：即将要进入的目标 路由对象</li>\n<li>from：Route：当前导航正要离开的路由</li>\n<li>next：Function：一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。\n<ul>\n<li>next()：进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed（确认的）。</li>\n<li>next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。</li>\n<li>next(\'/\') 或者 next({ path: \'/\' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: \'home\' 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。</li>\n<li>next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。</li>\n</ul>\n</li>\n</ul>\n<p>确保 <code>next</code> 函数在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错。这里有一个在用户未能验证身份时重定向到 <code>/login</code> 的示例：</p>\n<pre class="language-js"><code class="language-js"><span class="token comment">// BAD</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>to<span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">!==</span> <span class="token string">\'Login\'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isAuthenticated<span class="token punctuation">)</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">\'Login\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token comment">// 如果用户未能验证身份，则next会被调用两次</span>\n    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<pre class="language-js"><code class="language-js"><span class="token comment">// GOOD</span>\nrouter<span class="token punctuation">.</span><span class="token method function property-access">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>to<span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">!==</span> <span class="token string">\'Login\'</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isAuthenticated<span class="token punctuation">)</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">\'Login\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token keyword control-flow">else</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h4 id="%E5%85%A8%E5%B1%80%E8%A7%A3%E6%9E%90%E5%AE%88%E5%8D%AB">全局解析守卫<a class="anchor" href="#%E5%85%A8%E5%B1%80%E8%A7%A3%E6%9E%90%E5%AE%88%E5%8D%AB">§</a></h4>\n<p>在 2.5.0+ 你可以用 <code>router.beforeResolve</code> 注册一个全局守卫。这和 <code>router.beforeEach</code> 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。</p>\n<h4 id="%E5%85%A8%E5%B1%80%E5%90%8E%E7%BD%AE%E9%92%A9%E5%AD%90">全局后置钩子<a class="anchor" href="#%E5%85%A8%E5%B1%80%E5%90%8E%E7%BD%AE%E9%92%A9%E5%AD%90">§</a></h4>\n<p>你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身：</p>\n<pre class="language-js"><code class="language-js">router<span class="token punctuation">.</span><span class="token method function property-access">afterEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span></span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h4 id="%E8%B7%AF%E7%94%B1%E7%8B%AC%E4%BA%AB%E7%9A%84%E5%AE%88%E5%8D%AB">路由独享的守卫<a class="anchor" href="#%E8%B7%AF%E7%94%B1%E7%8B%AC%E4%BA%AB%E7%9A%84%E5%AE%88%E5%8D%AB">§</a></h4>\n<p>你可以在路由配置上直接定义 <code>beforeEnter</code> 守卫：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token punctuation">{</span>\n      path<span class="token operator">:</span> <span class="token string">\'/foo\'</span><span class="token punctuation">,</span>\n      component<span class="token operator">:</span> <span class="token maybe-class-name">Foo</span><span class="token punctuation">,</span>\n      <span class="token function-variable function">beforeEnter</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n        <span class="token comment">// ...</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>这些守卫与全局前置守卫的方法参数是一样的。</p>\n<h4 id="%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB">组件内的守卫<a class="anchor" href="#%E7%BB%84%E4%BB%B6%E5%86%85%E7%9A%84%E5%AE%88%E5%8D%AB">§</a></h4>\n<p>最后，你可以在路由组件内直接定义以下路由导航守卫：</p>\n<ul>\n<li>beforeRouteEnter</li>\n<li>beforeRouteUpdate (2.2 新增)</li>\n<li>beforeRouteLeave</li>\n</ul>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">Foo</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">...</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>\n  <span class="token function">beforeRouteEnter</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 在渲染该组件的对应路由被 confirm 前调用</span>\n    <span class="token comment">// 不！能！获取组件实例 `this`</span>\n    <span class="token comment">// 因为当守卫执行前，组件实例还没被创建</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function">beforeRouteUpdate</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 在当前路由改变，但是该组件被复用时调用</span>\n    <span class="token comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span>\n    <span class="token comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span>\n    <span class="token comment">// 可以访问组件实例 `this`</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function">beforeRouteLeave</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 导航离开该组件的对应路由时调用</span>\n    <span class="token comment">// 可以访问组件实例 `this`</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p><code>beforeRouteEnter</code> 守卫 不能 访问 <code>this</code>，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。</p>\n<p>不过，你可以通过传一个回调给 <code>next</code>来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p>\n<pre class="language-js"><code class="language-js"><span class="token function">beforeRouteEnter</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">next</span><span class="token punctuation">(</span><span class="token parameter">vm</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n    <span class="token comment">// 通过 `vm` 访问组件实例</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>注意 <code>beforeRouteEnter</code> 是支持给 <code>next</code> 传递回调的唯一守卫。对于 <code>beforeRouteUpdate</code> 和 <code>beforeRouteLeave</code> 来说，<code>this</code> 已经可用了，所以不支持传递回调，因为没有必要了。</p>\n<pre class="language-js"><code class="language-js"><span class="token function">beforeRouteUpdate</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// just use `this`</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">name</span> <span class="token operator">=</span> to<span class="token punctuation">.</span><span class="token property-access">params</span><span class="token punctuation">.</span><span class="token property-access">name</span>\n  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 <code>next(false)</code> 来取消。</p>\n<pre class="language-js"><code class="language-js"><span class="token function">beforeRouteLeave</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> answer <span class="token operator">=</span> <span class="token dom variable">window</span><span class="token punctuation">.</span><span class="token method function property-access">confirm</span><span class="token punctuation">(</span><span class="token string">\'Do you really want to leave? you have unsaved changes!\'</span><span class="token punctuation">)</span>\n  <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>answer<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n    <span class="token function">next</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h4 id="%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B">完整的导航解析流程<a class="anchor" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B">§</a></h4>\n<ol>\n<li>导航被触发。</li>\n<li>在失活的组件里调用 beforeRouteLeave 守卫。</li>\n<li>调用全局的 beforeEach 守卫。</li>\n<li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。</li>\n<li>在路由配置里调用 beforeEnter。</li>\n<li>解析异步路由组件。</li>\n<li>在被激活的组件里调用 beforeRouteEnter。</li>\n<li>调用全局的 beforeResolve 守卫 (2.5+)。</li>\n<li>导航被确认。</li>\n<li>调用全局的 afterEach 钩子。</li>\n<li>触发 DOM 更新。</li>\n<li>调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li>\n</ol>\n<h3 id="%E8%B7%AF%E7%94%B1%E5%85%83%E4%BF%A1%E6%81%AF">路由元信息<a class="anchor" href="#%E8%B7%AF%E7%94%B1%E5%85%83%E4%BF%A1%E6%81%AF">§</a></h3>\n<p>定义路由的时候可以配置 <code>meta</code> 字段：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  routes<span class="token operator">:</span> <span class="token punctuation">[</span>\n    <span class="token punctuation">{</span>\n      path<span class="token operator">:</span> <span class="token string">\'/foo\'</span><span class="token punctuation">,</span>\n      component<span class="token operator">:</span> <span class="token maybe-class-name">Foo</span><span class="token punctuation">,</span>\n      children<span class="token operator">:</span> <span class="token punctuation">[</span>\n        <span class="token punctuation">{</span>\n          path<span class="token operator">:</span> <span class="token string">\'bar\'</span><span class="token punctuation">,</span>\n          component<span class="token operator">:</span> <span class="token maybe-class-name">Bar</span><span class="token punctuation">,</span>\n          <span class="token comment">// a meta field</span>\n          meta<span class="token operator">:</span> <span class="token punctuation">{</span> requiresAuth<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">]</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>那么如何访问这个 <code>meta</code> 字段呢？</p>\n<p>首先，我们称呼 <code>routes</code> 配置中的每个路由对象为 路由记录。路由记录可以是嵌套的，因此，当一个路由匹配成功后，他可能匹配多个路由记录</p>\n<p>例如，根据上面的路由配置，/foo/bar 这个 URL 将会匹配父路由记录以及子路由记录。</p>\n<p>一个路由匹配到的所有路由记录会暴露为 <code>$route</code> 对象 (还有在导航守卫中的路由对象) 的 <code>$route.matched</code> 数组。因此，我们需要遍历 <code>$route.matched</code> 来检查路由记录中的 <code>meta</code> 字段。</p>\n<p>下面例子展示在全局导航守卫中检查元字段：</p>\n<pre class="language-js"><code class="language-js">router<span class="token punctuation">.</span><span class="token method function property-access">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>to<span class="token punctuation">.</span><span class="token property-access">matched</span><span class="token punctuation">.</span><span class="token method function property-access">some</span><span class="token punctuation">(</span>record<span class="token punctuation">.</span><span class="token property-access">meta</span><span class="token punctuation">.</span><span class="token property-access">requireAuth</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// this route requires auth, check if logged in</span>\n        <span class="token comment">// if not, redirect to login page.</span>\n        <span class="token keyword control-flow">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>auth<span class="token punctuation">.</span><span class="token method function property-access">loggedIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n                path<span class="token operator">:</span> <span class="token string">\'/login\'</span><span class="token punctuation">,</span>\n                query<span class="token operator">:</span> <span class="token punctuation">{</span> redirect<span class="token operator">:</span> to<span class="token punctuation">.</span><span class="token property-access">fullPath</span> <span class="token punctuation">}</span>\n            <span class="token punctuation">}</span><span class="token punctuation">)</span>\n        <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n            <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span> <span class="token keyword control-flow">else</span> <span class="token punctuation">{</span>\n        <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 确保一定要调用 next()</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h3 id="%E8%BF%87%E6%B8%A1%E5%8A%A8%E6%95%88">过渡动效<a class="anchor" href="#%E8%BF%87%E6%B8%A1%E5%8A%A8%E6%95%88">§</a></h3>\n<p><code>&lt;router-view&gt;</code> 是基本的动态组件，所以我们可以用 <code>&lt;transition&gt;</code> 组件给它添加一些过渡效果（同vue中的transition）：</p>\n<pre class="language-js"><code class="language-js"><span class="token operator">&lt;</span>transition<span class="token operator">></span>\n    <span class="token operator">&lt;</span>router<span class="token operator">-</span>view<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">></span>\n<span class="token operator">&lt;</span><span class="token operator">/</span>transition<span class="token operator">></span>\n</code></pre>\n<h4 id="%E5%8D%95%E4%B8%AA%E8%B7%AF%E7%94%B1%E7%9A%84%E8%BF%87%E6%B8%A1">单个路由的过渡<a class="anchor" href="#%E5%8D%95%E4%B8%AA%E8%B7%AF%E7%94%B1%E7%9A%84%E8%BF%87%E6%B8%A1">§</a></h4>\n<p>上面的用法会给所有路由设置一样的过渡效果，如果你想让每个路由组件有各自的过渡效果，可以在各路由组件内使用 <code>&lt;transition&gt;</code> 并设置不同的 <code>name</code>。</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token maybe-class-name">Foo</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n    template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">\n        &lt;transition name="slide">\n            &lt;div class="foo">...&lt;/div>\n        &lt;/transition>\n    </span><span class="token template-punctuation string">`</span></span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> <span class="token maybe-class-name">Bar</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n    template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">\n        &lt;transition name="fade">\n            &lt;div class="bar">...&lt;/div>\n        &lt;/transition>\n    </span><span class="token template-punctuation string">`</span></span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h4 id="%E5%9F%BA%E4%BA%8E%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8A%A8%E6%80%81%E8%BF%87%E6%B8%A1">基于路由的动态过渡<a class="anchor" href="#%E5%9F%BA%E4%BA%8E%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8A%A8%E6%80%81%E8%BF%87%E6%B8%A1">§</a></h4>\n<p>还可以基于当前路由与目标路由的变化关系，动态设置过渡效果：</p>\n<pre class="language-html"><code class="language-html"><span class="token comment">&lt;!-- 使用动态的 transition name --></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transition</span> <span class="token attr-name">:name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>transitionName<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transition</span><span class="token punctuation">></span></span>\n</code></pre>\n<pre class="language-js"><code class="language-js"><span class="token comment">// 接着在父组件内</span>\n<span class="token comment">// watch $route 决定使用哪种过渡</span>\nwatch<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token string">\'$route\'</span> <span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword module">from</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> toDepth <span class="token operator">=</span> to<span class="token punctuation">.</span><span class="token property-access">path</span><span class="token punctuation">.</span><span class="token method function property-access">split</span><span class="token punctuation">(</span><span class="token string">\'/\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">length</span>\n    <span class="token keyword">const</span> fromDepth <span class="token operator">=</span> <span class="token keyword module">from</span><span class="token punctuation">.</span><span class="token property-access">path</span><span class="token punctuation">.</span><span class="token method function property-access">split</span><span class="token punctuation">(</span><span class="token string">\'/\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token property-access">length</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">transitionName</span> <span class="token operator">=</span> toDepth <span class="token operator">&lt;</span> fromDepth <span class="token operator">?</span> <span class="token string">\'slide-right\'</span> <span class="token operator">:</span> <span class="token string">\'slide-left\'</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h3 id="%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96">数据获取<a class="anchor" href="#%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96">§</a></h3>'
        } }),
    'toc': React.createElement("aside", { dangerouslySetInnerHTML: {
            __html: '<nav class="toc"><ol><li><a href="#%E5%9F%BA%E7%A1%80">基础</a><ol><li><a href="#%E8%B5%B7%E6%AD%A5">起步</a><ol></ol></li><li><a href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D">动态路由匹配</a><ol></ol></li><li><a href="#%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1">嵌套路由</a></li><li><a href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E7%9A%84%E5%AF%BC%E8%88%AA">编程式的导航</a><ol></ol></li><li><a href="#%E5%91%BD%E5%90%8D%E8%B7%AF%E7%94%B1">命名路由</a></li><li><a href="#%E5%91%BD%E5%90%8D%E8%A7%86%E5%9B%BE">命名视图</a><ol></ol></li><li><a href="#%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E5%88%AB%E5%90%8D">重定向和别名</a><ol></ol></li><li><a href="#%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82">路由组件传参</a><ol></ol></li><li><a href="#html5-history-%E6%A8%A1%E5%BC%8F">HTML5 History 模式</a></li></ol></li><li><a href="#%E8%BF%9B%E9%98%B6">进阶</a><ol><li><a href="#%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB">导航守卫</a><ol></ol></li><li><a href="#%E8%B7%AF%E7%94%B1%E5%85%83%E4%BF%A1%E6%81%AF">路由元信息</a></li><li><a href="#%E8%BF%87%E6%B8%A1%E5%8A%A8%E6%95%88">过渡动效</a><ol></ol></li><li><a href="#%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96">数据获取</a></li></ol></li></ol></nav>'
        } }),
    'author': "jianyun2020",
    'contributors': [
        "jianyun2020"
    ],
    'date': "2021-03-17T08:01:47.000Z",
    'updated': "2021-03-18T08:43:37.000Z",
    'excerpt': "基础 起步 用 Vue.js + Vue Router 创建单页应用，感觉很自然：使用 Vue.js ，我们已经可以通过组合组件来组成应用程序，当你要把 Vue Router 添加进来，我们需要做的是，将组件 (components) 映射到路由 (routes)，然后告诉 V...",
    'cover': undefined,
    'categories': [
        "Vue"
    ],
    'tags': [
        "Vue Router",
        "学习笔记"
    ],
    'blog': {
        "isPost": true,
        "posts": [
            {
                "pagePath": "posts/Vue Router.md",
                "title": "Vue Router",
                "link": "posts/Vue Router.html",
                "date": "2021-03-17T08:01:47.000Z",
                "updated": "2021-03-18T08:43:37.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "Vue"
                ],
                "tags": [
                    "Vue Router",
                    "学习笔记"
                ],
                "excerpt": "基础 起步 用 Vue.js + Vue Router 创建单页应用，感觉很自然：使用 Vue.js ，我们已经可以通过组合组件来组成应用程序，当你要把 Vue Router 添加进来，我们需要做的是，将组件 (components) 映射到路由 (routes)，然后告诉 V..."
            },
            {
                "pagePath": "posts/Vuex.md",
                "title": "Vuex",
                "link": "posts/Vuex.html",
                "date": "2021-03-15T02:10:17.000Z",
                "updated": "2021-03-17T08:00:55.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "Vue"
                ],
                "tags": [
                    "Vuex",
                    "学习笔记"
                ],
                "excerpt": "Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容..."
            },
            {
                "pagePath": "posts/跨浏览器标签页通信.md",
                "title": "跨浏览器标签页通信",
                "link": "posts/跨浏览器标签页通信.html",
                "date": "2021-03-11T04:59:20.000Z",
                "updated": null,
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "HTML"
                ],
                "tags": [
                    "面试",
                    "跨页面通信",
                    "学习笔记"
                ],
                "excerpt": "在浏览器中，我们可以同时打开多个Tab页，每个Tab页可以粗略理解为一个“独立”的运行环境，即使是全局对象也不会在多个Tab间共享。然而有些时候，我们希望能在这些“独立”的Tab页面之间同步页面的数据、信息或状态。 正如下面...",
                "cover": "../posts/images/html.gif"
            },
            {
                "pagePath": "posts/动态规划.md",
                "title": "动态规划",
                "link": "posts/动态规划.html",
                "date": "2021-03-11T04:59:20.000Z",
                "updated": null,
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "算法"
                ],
                "tags": [
                    "面试",
                    "动态规划",
                    "学习笔记"
                ],
                "excerpt": "动态规划（英语：Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结..."
            },
            {
                "pagePath": "posts/history和hash两种路由.md",
                "title": "history和hash两种路由",
                "link": "posts/history和hash两种路由.html",
                "date": "2021-03-11T04:59:20.000Z",
                "updated": "2021-03-11T05:40:11.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "HTML"
                ],
                "tags": [
                    "面试",
                    "路由",
                    "学习笔记"
                ],
                "excerpt": "什么是SPA SPA 是 single page web application 的简称，译为单页Web应用。 简单的说 SPA 就是一个WEB项目只有一个 HTML 页面，一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转。 取而代之的是利用 JS 动...",
                "cover": "images/chuantong.png"
            },
            {
                "pagePath": "posts/行内元素和块级元素.md",
                "title": "行内元素和块级元素",
                "link": "posts/行内元素和块级元素.html",
                "date": "2021-03-04T13:28:28.000Z",
                "updated": null,
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "HTML"
                ],
                "tags": [
                    "行内元素和块级元素"
                ],
                "excerpt": "常用行内元素 - a：锚点 - span：常用内联容器，定义文本内区块 - label：表格标签 - strong：粗体强调 - em：强调 - br：换行 - img：图片 - input：输入框 - select：项目选择 - textarea：多行文本输入框 - cite：引用 常用..."
            },
            {
                "pagePath": "posts/继承.md",
                "title": "继承",
                "link": "posts/继承.html",
                "date": "2021-03-04T13:28:28.000Z",
                "updated": "2021-03-08T13:18:57.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "JavaScript"
                ],
                "tags": [
                    "学习笔记",
                    "继承",
                    "面试"
                ],
                "excerpt": "原型链继承 function Parent() { this.name = 'kevin'; } Parent.prototype.getName = function() { console.log(this.name); } function Child() { } Child.prototype = new Parent(); var child1 = new Child(); console.log..."
            },
            {
                "pagePath": "posts/111.md",
                "title": "每日总结",
                "link": "posts/111.html",
                "date": "2021-03-04T13:28:28.000Z",
                "updated": "2021-03-17T08:00:55.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "Vue"
                ],
                "tags": [
                    "面试",
                    "原型链",
                    "学习笔记"
                ],
                "excerpt": "周末时间利用"
            },
            {
                "pagePath": "posts/微信内置浏览器播放视频.md",
                "title": "微信内置X5内核浏览器播放视频相关问题",
                "link": "posts/微信内置浏览器播放视频.html",
                "date": "2021-03-03T12:50:17.000Z",
                "updated": "2021-03-03T13:18:54.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "微信的坑"
                ],
                "tags": [
                    "视频播放"
                ],
                "excerpt": "官网 原生video标签 <video id=\"vid\" src=\"./assets/test.mp4\" poster=\"./assets/test.png\" controls></video> X5内核视频两种播放形态 1. 页面内播放 X5内核视频在用户点击后默认会进入全屏播放，前端可以设置video的x5-plays...",
                "cover": "images/wx01.png"
            },
            {
                "pagePath": "posts/Golang基础.md",
                "title": "Golang基础",
                "link": "posts/Golang基础.html",
                "date": "2021-02-26T04:55:47.000Z",
                "updated": "2021-02-26T05:36:43.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "Golang"
                ],
                "tags": [
                    "学习笔记"
                ],
                "excerpt": "基本语法 package main import \"fmt\" func main() { // 此括号不能写在单独行 fmt.Println(\"Hello Go~\") } 格式化字符串 Go语言使用fmt.Sprintf格式化字符串并赋值给新串 package main import \"fmt\" func main() { // %d表示整..."
            },
            {
                "pagePath": "posts/原型链.md",
                "title": "原型链",
                "link": "posts/原型链.html",
                "date": "2021-02-25T14:45:38.000Z",
                "updated": "2021-03-04T13:37:41.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "JavaScript"
                ],
                "tags": [
                    "面试",
                    "原型链",
                    "学习笔记"
                ],
                "excerpt": "构造函数 本质就是函数，与普通函数一样，一般命名首字母大写来与普通函数区分，用new关键字调用。 **每个函数再创建时，会自动创建prototype属性，它指向一个对象，这个对象正是调用该构造函数而创建的实例的原型。**每一个Ja..."
            },
            {
                "pagePath": "posts/UE4.md",
                "title": "UE4学习笔记",
                "link": "posts/UE4.html",
                "date": "2021-02-01T04:46:51.000Z",
                "updated": "2021-03-11T09:31:40.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "UE4"
                ],
                "tags": [
                    "UE4",
                    "学习笔记"
                ],
                "excerpt": " 1. 常用快捷键 2. 变更路线节点：Reroute Node 3. Execute Console Command命令 1. 设置分辨率r.setRes 1920x1080 2. r.ScreenPercentage 200：双倍渲染 UE4像素流送系统 特点： 1. 流送并非播放预先录制的视频片段，而是播放...",
                "cover": "images/shortcut_key1.png"
            },
            {
                "pagePath": "posts/React笔记.md",
                "title": "React学习笔记",
                "link": "posts/React笔记.html",
                "date": "2021-01-29T14:58:22.000Z",
                "updated": "2021-02-21T23:30:13.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "React"
                ],
                "tags": [
                    "React",
                    "学习笔记"
                ],
                "excerpt": " 1. 在html中简易使用jsx语法时，需要引入babel插件，同时设置<script type=\"text/babel\"></script> 2. js语法创建虚拟DOM：React.createElement('h1', {id: 'test'}, 'Hello, React') 3. 关于虚拟DOM： 1. 本质就是Object类型...",
                "cover": "images/lifeold.png"
            },
            {
                "pagePath": "posts/前端基础面试题.md",
                "title": "HTML篇",
                "link": "posts/前端基础面试题.html",
                "date": "2021-01-27T07:14:50.000Z",
                "updated": "2021-02-01T04:46:51.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "面试"
                ],
                "tags": [
                    "面试",
                    "HTML",
                    "CSS",
                    "JavaScript"
                ],
                "excerpt": "说说title和alt属性 HTML5有哪些新特性、移除了哪些元素 iframe有那些缺点？ HTML W3C的标准 Doctype作用? 严格模式与混杂模式如何区分？它们有何意义? HTML全局属性(global attribute)有哪些 viewport的content属性作用 div+c..."
            },
            {
                "pagePath": "posts/前端本地存储.md",
                "title": "前端本地存储",
                "link": "posts/前端本地存储.html",
                "date": "2021-01-27T03:51:39.000Z",
                "updated": null,
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "面试"
                ],
                "tags": [
                    "面试",
                    "学习笔记",
                    "前端本地存储"
                ],
                "excerpt": "cookie 作用 cookie是纯文本，没有可执行代码。存储数据，当用户访问了某个网站（网页）的时候，我们就可以通过cookie来向访问者电脑上存储数据，或者某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（..."
            },
            {
                "pagePath": "posts/跨域及常见解决办法.md",
                "title": "跨域及常见解决方法",
                "link": "posts/跨域及常见解决办法.html",
                "date": "2021-01-26T10:06:49.000Z",
                "updated": null,
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "面试"
                ],
                "tags": [
                    "面试",
                    "学习笔记",
                    "跨域"
                ],
                "excerpt": "什么是跨域 跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。 广义的跨域： 1. 资源跳转：A链接、重定向、表单提交 2. 资源嵌入：<link>、<script>、<img>、<frame>等dom标签，还有样式中backgrou..."
            },
            {
                "pagePath": "posts/垃圾回收机制.md",
                "title": "垃圾回收机制",
                "link": "posts/垃圾回收机制.html",
                "date": "2021-01-26T03:09:41.000Z",
                "updated": "2021-01-26T06:08:48.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "面试"
                ],
                "tags": [
                    "面试",
                    "学习笔记",
                    "垃圾回收机制"
                ],
                "excerpt": "JavaScript具有自动垃圾收集机制(GC:GarbageCollection)，也就是说，执行环境会负责管理代码执行过程中使用的内存。开发人员不用再关心内存使用问题，所需内存的分配以及无用内存的回收完全实现了自动管理。 内存生命周期 JS环...",
                "cover": "./images/markandsweep.png"
            },
            {
                "pagePath": "posts/防抖和节流.md",
                "title": "防抖和节流",
                "link": "posts/防抖和节流.html",
                "date": "2021-01-25T10:51:54.000Z",
                "updated": "2021-01-26T03:09:41.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "面试"
                ],
                "tags": [
                    "面试",
                    "防抖和节流",
                    "学习笔记"
                ],
                "excerpt": " - 相同：在不影响客户体验的前提下，将频繁的回调函数，进行次数缩减，避免大量计算导致页的页面卡顿。 - 不同：防抖是将多次执行变为最后一次执行，节流是将多次执行变为在规定时间内只执行一次。 防抖 定义：指触发事件后在..."
            },
            {
                "pagePath": "posts/css_渐变.md",
                "title": "CSS渐变",
                "link": "posts/css_渐变.html",
                "date": "2021-01-25T09:32:57.000Z",
                "updated": null,
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "CSS"
                ],
                "tags": [
                    "CSS",
                    "学习笔记",
                    "渐变"
                ],
                "excerpt": "CSS渐变<image>类型的一种特殊类型<gradient>表示，由两种或多种颜色之间的渐进过渡组成。有三种类型的渐变： - 线性（由linear-gradient()函数创建） - 径向（由radial-gradient()函数创建） - 圆锥（由conic-gradient()函数创...",
                "cover": "./images/deg.png"
            },
            {
                "pagePath": "posts/css_background.md",
                "title": "CSS的background属性详解",
                "link": "posts/css_background.html",
                "date": "2021-01-25T07:07:55.000Z",
                "updated": "2021-01-25T08:30:22.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "CSS"
                ],
                "tags": [
                    "CSS",
                    "学习笔记",
                    "background"
                ],
                "excerpt": "background是一中CSS简写属性，可以在一次声明中定义一个或多个属性：background-clip、background-color、background-image、background-origin、background-position、background-repeat、background-size、background-attac..."
            },
            {
                "pagePath": "posts/Hook.md",
                "title": "Hook",
                "link": "posts/Hook.html",
                "date": "2021-01-25T07:07:55.000Z",
                "updated": null,
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "React"
                ],
                "tags": [
                    "JavaScript",
                    "学习笔记",
                    "React"
                ],
                "excerpt": "16.8版本新增特性。可以在不编写class的情况下使用state以及其它的React特性。 import React, { useState } from 'react'; function Example() { // 声明一个新的叫做“count”的state变量 const [count, setCount] = useState..."
            },
            {
                "pagePath": "posts/元素渲染.md",
                "title": "React-元素渲染",
                "link": "posts/元素渲染.html",
                "date": "2021-01-22T08:08:14.000Z",
                "updated": null,
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "React"
                ],
                "tags": [
                    "JavaScript",
                    "学习笔记",
                    "React"
                ],
                "excerpt": "元素是构成React应用的最小砖块，其描述了你在屏幕上想看到的内容。 const element = <h1>Hello, World</h1>; 与浏览器的 DOM 元素不同，React 元素是创建开销极小的普通对象。React DOM 会负责更新 DOM 来与 React 元素保持一..."
            },
            {
                "pagePath": "posts/List.md",
                "title": "数据结构与算法JavaScript-列表",
                "link": "posts/List.html",
                "date": "2021-01-22T08:08:14.000Z",
                "updated": "2021-01-25T02:27:19.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "数据结构与算法"
                ],
                "tags": [
                    "JavaScript",
                    "数据结构与算法",
                    "学习笔记"
                ],
                "excerpt": "列表的抽象数据类型定义 方法和方法 说明 listSize(属性) 列表的元素个数 pos(属性) 列表的当前位置 length(属性) 返回列表中元素的个数 clear(方法) 清空列表中的所有元素 toString(方法) 返回列表的字符串形式 getElement(方..."
            },
            {
                "pagePath": "posts/JSX简介.md",
                "title": "React-JSX简介",
                "link": "posts/JSX简介.html",
                "date": "2021-01-21T07:25:11.000Z",
                "updated": null,
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "React"
                ],
                "tags": [
                    "JavaScript",
                    "学习笔记",
                    "React"
                ],
                "excerpt": "考虑如下变量声明： const element = <h1>Hello, world!</h1>; 这个有趣的标签语法既不是字符串也不是 HTML。它被称为 JSX，是一个 JavaScript 的语法扩展。 在JSX中嵌入表达式 const name = 'Bob'; const element = <h1>Hello..."
            },
            {
                "pagePath": "posts/Array.md",
                "title": "数据结构与算法JavaScript-数组",
                "link": "posts/Array.html",
                "date": "2021-01-20T05:13:02.000Z",
                "updated": "2021-01-21T06:40:51.000Z",
                "author": "jianyun2020",
                "contributors": [
                    "jianyun2020"
                ],
                "categories": [
                    "数据结构与算法"
                ],
                "tags": [
                    "JavaScript",
                    "数据结构与算法",
                    "学习笔记"
                ],
                "excerpt": "数组 JavaScript 中的数组是一种特殊的对象， 用来表示偏移量的索引是该对象的属性， 索引可 能是整数。 然而， 这些数字索引在内部被转换为字符串类型， 这是因为 JavaScript 对象中 的属性名必须是字符串。 数组在 JavaScrip..."
            }
        ],
        "categories": [
            {
                "name": "面试",
                "count": 5
            },
            {
                "name": "React",
                "count": 4
            },
            {
                "name": "HTML",
                "count": 3
            },
            {
                "name": "Vue",
                "count": 3
            },
            {
                "name": "CSS",
                "count": 2
            },
            {
                "name": "JavaScript",
                "count": 2
            },
            {
                "name": "数据结构与算法",
                "count": 2
            },
            {
                "name": "Golang",
                "count": 1
            },
            {
                "name": "UE4",
                "count": 1
            },
            {
                "name": "微信的坑",
                "count": 1
            },
            {
                "name": "算法",
                "count": 1
            }
        ],
        "tags": [
            {
                "name": "学习笔记",
                "count": 22
            },
            {
                "name": "面试",
                "count": 11
            },
            {
                "name": "JavaScript",
                "count": 6
            },
            {
                "name": "React",
                "count": 4
            },
            {
                "name": "CSS",
                "count": 3
            },
            {
                "name": "原型链",
                "count": 2
            },
            {
                "name": "数据结构与算法",
                "count": 2
            },
            {
                "name": "background",
                "count": 1
            },
            {
                "name": "HTML",
                "count": 1
            },
            {
                "name": "UE4",
                "count": 1
            },
            {
                "name": "Vue Router",
                "count": 1
            },
            {
                "name": "Vuex",
                "count": 1
            },
            {
                "name": "前端本地存储",
                "count": 1
            },
            {
                "name": "动态规划",
                "count": 1
            },
            {
                "name": "垃圾回收机制",
                "count": 1
            },
            {
                "name": "渐变",
                "count": 1
            },
            {
                "name": "继承",
                "count": 1
            },
            {
                "name": "行内元素和块级元素",
                "count": 1
            },
            {
                "name": "视频播放",
                "count": 1
            },
            {
                "name": "跨域",
                "count": 1
            },
            {
                "name": "跨页面通信",
                "count": 1
            },
            {
                "name": "路由",
                "count": 1
            },
            {
                "name": "防抖和节流",
                "count": 1
            }
        ]
    }
};
